single_input: _NEWLINE | simple_stmt | compound_stmt _NEWLINE
file_input: (_NEWLINE | stmt)*

funcdef: name "(" [parameters] ")" _NEWLINE block_stmt

parameters: name ("," name)*

?stmt: simple_stmt | compound_stmt
simple_stmt: small_stmt (";" small_stmt)* [";"] _NEWLINE
?small_stmt: (expr_stmt | assign_stmt | flow_stmt | decl_stmt)
expr_stmt: test
assign_stmt: assign

?decl_stmt: array_decl_stmt

array_decl_stmt: single_array_decl
    | multiple_array_decl
array_init: name "[" arith_expr ":" arith_expr "]"
single_array_decl: "let" array_init "be" "a" "new" "array"
multiple_array_decl: "let" array_init ("and" array_init)+ "be" "new" "arrays"

?flow_stmt: return_stmt | print_stmt | error_stmt | exchange_stmt
return_stmt: "return" test
print_stmt: "print" test
error_stmt: "error" string
exchange_stmt: ("exchange" | "swap") atom_expr "with" atom_expr
// TODO: implement more statements into compound_stmt (e.g. repeat)
?compound_stmt: if_stmt
    | while_stmt
    | for_stmt
    | repeat_stmt
    | funcdef
// FIXME: It is not clear/easy to determine if an if_stmt contains an else branch
// the 'else' grammar should be extracted to its own rule
if_stmt: "if" test _NEWLINE block_stmt elifs else_?
elifs: elif_*
elif_: "else" "if" test _NEWLINE block_stmt
else_: else_block | else_inline
else_block: "else" _NEWLINE block_stmt
else_inline: "else" simple_stmt block_stmt?
while_stmt: "while" test _NEWLINE block_stmt
for_stmt: for_loop
        | for_iter
for_loop: "for" name "=" test range_op test _NEWLINE block_stmt
for_iter: "for" "each" name name "in" name _NEWLINE block_stmt // first 'name' token should be discarded
!range_op: "to"
    | "downto"
repeat_stmt: "repeat" _NEWLINE block_stmt "until" test _NEWLINE

block_stmt: simple_stmt | _INDENT stmt+ _DEDENT

assign: test "=" test

?test: comparison
    | assign_expr

assign_expr: name "=" test

?comparison: expr (_comp_op expr)*

?expr: or_expr

?or_expr: xor_expr ("or" xor_expr)*
?xor_expr: and_expr ("xor" and_expr)*
?and_expr: shift_expr ("and" shift_expr)*
?shift_expr: arith_expr (_shift_op arith_expr)*
?arith_expr: term (_add_op term)*
?term: factor (_mul_op factor)*
?factor: _unary_op factor | power

!_unary_op: "+" | "-" | "!"
!_add_op: "+" | "-"
!_shift_op: "<<" | ">>"
!_mul_op: "*" | "/" | "mod" | "\\\\"
!_comp_op: "<" | ">" | "==" | ">=" | "<=" | "!=" | "in" | "not" "in" | "is" | "is" "not"
!_power_op: "^" | "**"

?power: atom_expr (_power_op factor)*

?atom_expr: atom_expr "(" [arguments] ")"   -> funccall
            | atom_expr "[" test "]"        -> getitem
            | atom_expr "." name            -> getattr
            | atom

?atom: name         -> var
    | number
    | string
    | "(" test ")"  -> grouping
    | "NIL"         -> const_nil
    | "TRUE"        -> const_true
    | "FALSE"       -> const_false


arguments: test ("," test)*

number: DEC_INTEGER | DEC_REAL
string: STRING

// other terminals

_NEWLINE: ( /\r?\n[\t ]*/ | COMMENT )+

%ignore /[\t \f]+/ // whitespace
%ignore /\\[\t \f]*\r?\n/ // LINE_CONTINUATION
%declare _INDENT _DEDENT

// more terminals

!name: NAME
NAME: /[a-zA-Z$]{1}[a-zA-Z0-9'\-_^${}\\]*/
COMMENT: /\/\/[^\n]*/

%import common.ESCAPED_STRING -> STRING

DEC_INTEGER: /[1-9][0-9]*/
    | /0+/
DEC_REAL: /[1-9][0-9]*\.[0-9]+/
    | /0+\.0+/

