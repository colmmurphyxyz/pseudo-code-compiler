BUBBLESORT(A, n)
    for i = 1 to n - 1
        for j = n downto i + 1
            if A[j] < A[j - 1]
                exchange A[j] with A[j - 1]

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

A = [5, 4, 3, 2, 1]
print A
INSERTION-SORT(A, 5)
print A

MERGE(A, p, q, r)
    // this is a comment
    n$_L$ = q - p + 1
    n$_R$ = r - q
    let L[0:n$_L$ - 1] and R[0:n$_R$ - 1] be new arrays
    for i = 0 to n$_L$ - 1
        L[i] = A[p + i]
    for j = 0 to n$_R$ - 1
        R[j] = A[q + j + 1]
    i = 0
    j = 0
    k = p
    while i < n$_L$ and j < n$_R$
        if L[i] <= R[j]
            A[k] = L[i]
            i = i + 1
        else A[k] = R[j]
            j = j + 1
        k = k + 1
    while i < n$_L$
        A[k] = L[i]
        i = i + 1
        k = k + 1
    while j < n$_R$
        A[k] = R[j]
        j = j + 1
        k = k + 1

let A[1:10] be a new array
for i = 1 to 5
    A[i] = i + 10
    A[i + 5] = i + 10

print A
MERGE(A, 1, 5, 10)
print A

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

let A$_l$[1:5] be a new array
for i = 1 to 5
    A$_l$[i] = 6 - i
print A$_l$
INSERTION-SORT(A$_l$, 5)
print A$_l$

MATRIX-MULTIPLY(A, B, C, n)
    for i = 1 to n
        for j = 1 to n
            for k = 1 to n
                C[i][j] = C[i][j] + A[i][k] * B[k][j]

ONLINE-MAXIMUM(k, n)
    best-score = -infinity
    for i = 1 to k
        if score(i) > best-score
            best-score = score(i)
    for i = k + 1 to n
        if score(i) > best-score
            return i
    return n

PERMUTE-BY-CYCLE(A, n)
    let B[1:n] be a new array
    offset = RANDOM(1, n)
    for i = 1 to n
        dest = i + offset
        if dest > n
            dest = dest - n
        B[dest] = A[i]
    return B

let A[1:20] be a new array
for i = 1 to 20
    A[i] = 10 * i + RANDOM(0, 9)
print A
B = PERMUTE-BY-CYCLE(A, 20)
print B

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.1
PARENT(i)
    // could alternatively use i \\ 2
    return floor(i / 2)

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MIN-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] < A[i]
        smallest = l
    else
        smallest = i
    if r <= A.heap-size and A[r] < A[smallest]
        smallest = r
    if smallest != i
        exchange A[i] with A[smallest]
        MIN-HEAPIFY(A, smallest)

MIN-HEAP-MINIMUM(A)
    if A.heap-size < 1
        error "heap underflow"
    return A[1]

BUILD-MIN-HEAP(A, n)
    A.heap-size = n
    for i = PARENT(n) downto 1
        MIN-HEAPIFY(A, i)

EXTRACT-MIN(A)
    min = A[1]
    A[1] = A[A.heap-size]
    A.heap-size = A.heap-size - 1
    MIN-HEAPIFY(A, 1)
    return min

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MAX-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] > A[i]
        largest = l
    else largest = i
    if r <= A.heap-size and A[r] > A[largest]
        largest = r
    if largest != i
        exchange A[i] with A[largest]
        MAX-HEAPIFY(A, largest)

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.4
HEAPSORT(A, n)
    BUILD-MAX-HEAP(A, n)
    for i = n downto 2
        exchange A[1] with A[i]
        A.heap-size = A.heap-size - 1
        MAX-HEAPIFY(A, 1)

PARTITION(A, p, r)
    x = A[r]
    i = p - 1
    for j = p to r - 1
        if A[j] <= x
            i = i + 1
            exchange A[i] with A[j]
    exchange A[i + 1] with A[r]
    return i + 1

QUICKSORT(A, p, r)
    if p < r
        q = PARTITION(A, p, r)
        QUICKSORT(A, p, q - 1)
        QUICKSORT(A, q + 1, r)

COUNTING-SORT(A, n, k)
    let B[1:n] and C[0:k] be new arrays
    for i = 0 to k
        C[i] = 0
    for j = 1 to n
        C[A[j]] = C[A[j]] + 1
    // C[i] now contains the number of elements equal to i
    for i = 1 to k
        C[i] = C[i] + C[i - 1]
    // C[i] now contains the number of elements less than or equal to i
    // Copy A to B, starting from the enf od A
    for j = n downto 1
        B[C[A[j]]] = A[j]
        C[A[j]] = C[A[j]] - 1 // to handle duplicate values
    return B

LIST-INSERT(x, y)
    x.next = y.next
    x.prev = y
    if y.next != NIL
        y.next.prev = x
    y.next = x

LIST-INSERT'(x, y)
    x.next = y.next
    x.prev = y
    y.next.prev = x
    y.next = x

LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-SEARCH'(L, k)
    L.nil.key = k
    x = L.nil.next
    while x.key != k
        x = x.next
    if x == L.nil
        return NIL
    else return x

ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

STACK-EMPTY(S)
    if S.top == 0
        return TRUE
    else return FALSE

PUSH(S, x)
    if S.top == S.size
        error "overflow"
    else
        S.top = S.top + 1
        S[S.top] = x

POP(S)
    if STACK-EMPTY(S)
        error "underflow"
    else
        S.top = S.top - 1
        return S[S.top + 1]

// section 11.2

// linked list algorithms
LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-DELETE(L, x)
    if x.prev != NIL
        x.prev.next = x.next
    else L.head = x.next
    if x.next != NIL
        x.next.prev = x.prev

// dummy hash function impl.
h(x)
    return x

CHAINED-HASH-INSERT(T, k, x)
    let N[NIL,NIL,k,x] be a new listnode
    LIST-PREPEND(T[h(N.key)], N)

CHAINED-HASH-SEARCH(T, k)
    found = LIST-SEARCH(T[h(k)], k)
    if found != NIL
        return found.value
    else return NIL

CHAINED-HASH-DELETE(T, k)
    subject = LIST-SEARCH(T[h(k)], k)
    LIST-DELETE(T[h(k)], subject)

INORDER-TREE-WALK(x)
    if x != NIL
        INORDER-TREE-WALK(x.left)
        print x.key
        INORDER-TREE-WALK(x.right)

TREE-SEARCH(x, k)
    if x == NIL or k == x.key
        return x
    if k < x.key
        return TREE-SEARCH(x.left, k)
    else return TREE-SEARCH(x.right, k)

ITERATIVE-TREE-SEARCH(x, k)
    while x != NIL and k != x.key
        if k < x.key
            x = x.left
        else x = x.right
    return x

TREE-MINIMUM(x)
    while x.left != NIL
        x = x.left
    return x

TREE-MAXIMUM(x)
    while x.right != NIL
        x = x.right
    return x

TREE-INSERT(T, z)
    x = T.root
    y = NIL
    while x != NIL
        y = x
        if z.key < x.key
            x = x.left
        else x = x.right
    z.p = y
    if y == NIL
        T.root = z
    else if z.key < y.key
        y.left = z
    else y.right = z

TRANSPLANT(T, u, v)
    if u.p == NIL
        T.root = v
    else if u == u.p.left
        u.p.left = v
    else u.p.right = v
    if v != NIL
        v.p = u.p

TREE-DELETE(T, z)
    if z.left == NIL
        TRANSPLANT(T, z, z.right)
    else if z.right == NIL
        TRANSPLANT(T, z, z.left)
    else y = TREE-MINIMUM(z.right)
        if y != z.right
            TRANSPLANT(T, y, y.right)
            y.right = z.right
            y.right.p = y
        TRANSPLANT(T, z, y);
        y.left = z.left
        y.left.p = y

CUT-ROD(p, n)
    if n == 0
        return 0
    q = -$\infty$
    for i = 1 to n
        q = max(q, p[i] + CUT-ROD(p, n - i))
    return q

MEMOIZED-CUT-ROD(p, n)
    let r[0:n] be a new array
    for i = 0 to n
        r[i] = -$\infty$
    return MEMOIZED-CUT-ROD-AUX(p, n, r)

MEMOIZED-CUT-ROD-AUX(p, n, r)
    if r[n] >= 0
        return r[n]
    if n == 0
        q = 0
    else q = -$\infty$
        for i = 1 to n
            q = max(q, p[i] + MEMOIZED-CUT-ROD(p, n - i, r))
    r[n] = q
    return q

BOTTOM-UP-CUT-ROD(p, n)
    let r[0:n] be a new array
    r[0] = 0
    for j = 1 to n
        q = -$\infty$
        for i = 1 to j
            q = max(q, p[i] + r[j - i])
        r[j] = q
    return r[n]

let prices[1:10] be a new array
prices[1] = 1
prices[2] = 5
prices[3] = 8
prices[4] = 9
prices[5] = 12
prices[6] = 17
prices[7] = 17
prices[8] = 20
prices[9] = 24
prices[10] = 30
n = 4
max-price = CUT-ROD(prices, n)
print max-price

// Priority Queues
LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

PARENT(i)
    return i / 2

INSERT(Q, u)
    Q.heap-size = Q.heap-size + 1
    Q[Q.heap-size] = u
    DECREASE-KEY(Q, u, u.d)

MIN-HEAPIFY(Q, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= Q.heap-size and Q[l].d < Q[i].d
        smallest = l
    else
        smallest = i
    if r <= Q.heap-size and Q[r].d < Q[smallest].d
        smallest = r
    if smallest != i
        exchange Q[i] with Q[smallest]
        MIN-HEAPIFY(Q, smallest)

EXTRACT-MIN(Q)
    min = Q[1]
    Q[1] = Q[Q.heap-size]
    Q.heap-size = Q.heap-size - 1
    MIN-HEAPIFY(Q, 1)
    return min

DECREASE-KEY(Q, v, k)
    for i = 1 to Q.heap-size
        // key will have already been adjusted by RELAX
        if Q[i].key == v.key
            Q[i].d = k
            exchange Q[i] with Q[1]
            MIN-HEAPIFY(Q, 1)

INITIALIZE-SINGLE-SOURCE(G, s)
    for each vertex v in G.V
        v.d = $\infty$
        v.$\pi$ = NIL
    s.d = 0

RELAX(u, v, w)
    if v.d > u.d + w(u, v)
        v.d = u.d + w(u, v)
        v.$\pi$ = u
        return TRUE
    return FALSE

SET-UNION(s, v)
    return s + v

DIJKSTRA(G, w, s)
    INITIALIZE-SINGLE-SOURCE(G, s);
    let S be a new set
    let Q[len(G.V)] be a new priorityqueue
    for each vertex v in G.V
        INSERT(Q, v)
    while Q
        u = EXTRACT-MIN(Q)
        S = S | {u}
        for each vertex v in G.Adj(u)
            did-decrease = RELAX(u, v, w)
            if did-decrease
                DECREASE-KEY(Q, v, v.d)


DIJKSTRA-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 10
    adj-mat[1][4] = 5
    adj-mat[2][3] = 1
    adj-mat[2][4] = 2
    adj-mat[3][5] = 4
    adj-mat[4][2] = 3
    adj-mat[4][3] = 9
    adj-mat[4][5] = 2
    adj-mat[5][3] = 6

    w(u, v)
        return adj-mat[u.key][v.key]

    let G[adj-mat] be a new graph
    DIJKSTRA(G, w, G.V[1])
    print "done"

    for each u in G.V
        print u

DIJKSTRA-EXAMPLE()

// Queue operations
ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

BFS(G, s)
    // for each vertex u in G.V - {s}
    for each vertex u in G.V
        if u == s
            continue
        u.color = WHITE
        u.d = $\infty$
        u.$\pi$ = NIL
    s.color = GRAY
    s.d = 0
    s.$\pi$ = NIL
    let Q[len(G.V) + 1] be a new queue
    ENQUEUE(Q, s)
    while len(Q) > 0
        u = DEQUEUE(Q)
        for each vertex v in G.Adj(u)
            if v.color == WHITE
                v.color = GRAY
                v.d = u.d + 1
                v.$\pi$ = u
                ENQUEUE(Q, v)
        u.color = BLACK

BFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    BFS(G, G.V[1])
    for each u in G.V
        print u

DFS(G)
    for each vertex u in G.V
        u.color = WHITE
        u.$\pi$ = NIL
    time = 0
    for each vertex u in G.V
        if u.color == WHITE
            DFS-VISIT(G, u, time)

DFS-VISIT(G, u, time)
    time = time + 1
    u.d = time
    u.color = GRAY
    for each vertex v in G.Adj(u)
        if v.color == WHITE
            v.$\pi$ = u
            DFS-VISIT(G, v, time)
    u.color = BLACK
    time = time + 1
    u.f = time

DFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    DFS(G)
    for each u in G.V
        print str(u) + " f=" + str(u.f)

BUBBLESORT(A, n)
    for i = 1 to n - 1
        for j = n downto i + 1
            if A[j] < A[j - 1]
                exchange A[j] with A[j - 1]

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

A = [5, 4, 3, 2, 1]
print A
INSERTION-SORT(A, 5)
print A

MERGE(A, p, q, r)
    // this is a comment
    n$_L$ = q - p + 1
    n$_R$ = r - q
    let L[0:n$_L$ - 1] and R[0:n$_R$ - 1] be new arrays
    for i = 0 to n$_L$ - 1
        L[i] = A[p + i]
    for j = 0 to n$_R$ - 1
        R[j] = A[q + j + 1]
    i = 0
    j = 0
    k = p
    while i < n$_L$ and j < n$_R$
        if L[i] <= R[j]
            A[k] = L[i]
            i = i + 1
        else A[k] = R[j]
            j = j + 1
        k = k + 1
    while i < n$_L$
        A[k] = L[i]
        i = i + 1
        k = k + 1
    while j < n$_R$
        A[k] = R[j]
        j = j + 1
        k = k + 1

let A[1:10] be a new array
for i = 1 to 5
    A[i] = i + 10
    A[i + 5] = i + 10

print A
MERGE(A, 1, 5, 10)
print A

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

let A$_l$[1:5] be a new array
for i = 1 to 5
    A$_l$[i] = 6 - i
print A$_l$
INSERTION-SORT(A$_l$, 5)
print A$_l$

MATRIX-MULTIPLY(A, B, C, n)
    for i = 1 to n
        for j = 1 to n
            for k = 1 to n
                C[i][j] = C[i][j] + A[i][k] * B[k][j]

ONLINE-MAXIMUM(k, n)
    best-score = -infinity
    for i = 1 to k
        if score(i) > best-score
            best-score = score(i)
    for i = k + 1 to n
        if score(i) > best-score
            return i
    return n

PERMUTE-BY-CYCLE(A, n)
    let B[1:n] be a new array
    offset = RANDOM(1, n)
    for i = 1 to n
        dest = i + offset
        if dest > n
            dest = dest - n
        B[dest] = A[i]
    return B

let A[1:20] be a new array
for i = 1 to 20
    A[i] = 10 * i + RANDOM(0, 9)
print A
B = PERMUTE-BY-CYCLE(A, 20)
print B

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.1
PARENT(i)
    // could alternatively use i \\ 2
    return floor(i / 2)

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MIN-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] < A[i]
        smallest = l
    else
        smallest = i
    if r <= A.heap-size and A[r] < A[smallest]
        smallest = r
    if smallest != i
        exchange A[i] with A[smallest]
        MIN-HEAPIFY(A, smallest)

MIN-HEAP-MINIMUM(A)
    if A.heap-size < 1
        error "heap underflow"
    return A[1]

BUILD-MIN-HEAP(A, n)
    A.heap-size = n
    for i = PARENT(n) downto 1
        MIN-HEAPIFY(A, i)

EXTRACT-MIN(A)
    min = A[1]
    A[1] = A[A.heap-size]
    A.heap-size = A.heap-size - 1
    MIN-HEAPIFY(A, 1)
    return min

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MAX-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] > A[i]
        largest = l
    else largest = i
    if r <= A.heap-size and A[r] > A[largest]
        largest = r
    if largest != i
        exchange A[i] with A[largest]
        MAX-HEAPIFY(A, largest)

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.4
HEAPSORT(A, n)
    BUILD-MAX-HEAP(A, n)
    for i = n downto 2
        exchange A[1] with A[i]
        A.heap-size = A.heap-size - 1
        MAX-HEAPIFY(A, 1)

PARTITION(A, p, r)
    x = A[r]
    i = p - 1
    for j = p to r - 1
        if A[j] <= x
            i = i + 1
            exchange A[i] with A[j]
    exchange A[i + 1] with A[r]
    return i + 1

QUICKSORT(A, p, r)
    if p < r
        q = PARTITION(A, p, r)
        QUICKSORT(A, p, q - 1)
        QUICKSORT(A, q + 1, r)

COUNTING-SORT(A, n, k)
    let B[1:n] and C[0:k] be new arrays
    for i = 0 to k
        C[i] = 0
    for j = 1 to n
        C[A[j]] = C[A[j]] + 1
    // C[i] now contains the number of elements equal to i
    for i = 1 to k
        C[i] = C[i] + C[i - 1]
    // C[i] now contains the number of elements less than or equal to i
    // Copy A to B, starting from the enf od A
    for j = n downto 1
        B[C[A[j]]] = A[j]
        C[A[j]] = C[A[j]] - 1 // to handle duplicate values
    return B

LIST-INSERT(x, y)
    x.next = y.next
    x.prev = y
    if y.next != NIL
        y.next.prev = x
    y.next = x

LIST-INSERT'(x, y)
    x.next = y.next
    x.prev = y
    y.next.prev = x
    y.next = x

LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-SEARCH'(L, k)
    L.nil.key = k
    x = L.nil.next
    while x.key != k
        x = x.next
    if x == L.nil
        return NIL
    else return x

ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

STACK-EMPTY(S)
    if S.top == 0
        return TRUE
    else return FALSE

PUSH(S, x)
    if S.top == S.size
        error "overflow"
    else
        S.top = S.top + 1
        S[S.top] = x

POP(S)
    if STACK-EMPTY(S)
        error "underflow"
    else
        S.top = S.top - 1
        return S[S.top + 1]

// section 11.2

// linked list algorithms
LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-DELETE(L, x)
    if x.prev != NIL
        x.prev.next = x.next
    else L.head = x.next
    if x.next != NIL
        x.next.prev = x.prev

// dummy hash function impl.
h(x)
    return x

CHAINED-HASH-INSERT(T, k, x)
    let N[NIL,NIL,k,x] be a new listnode
    LIST-PREPEND(T[h(N.key)], N)

CHAINED-HASH-SEARCH(T, k)
    found = LIST-SEARCH(T[h(k)], k)
    if found != NIL
        return found.value
    else return NIL

CHAINED-HASH-DELETE(T, k)
    subject = LIST-SEARCH(T[h(k)], k)
    LIST-DELETE(T[h(k)], subject)

INORDER-TREE-WALK(x)
    if x != NIL
        INORDER-TREE-WALK(x.left)
        print x.key
        INORDER-TREE-WALK(x.right)

TREE-SEARCH(x, k)
    if x == NIL or k == x.key
        return x
    if k < x.key
        return TREE-SEARCH(x.left, k)
    else return TREE-SEARCH(x.right, k)

ITERATIVE-TREE-SEARCH(x, k)
    while x != NIL and k != x.key
        if k < x.key
            x = x.left
        else x = x.right
    return x

TREE-MINIMUM(x)
    while x.left != NIL
        x = x.left
    return x

TREE-MAXIMUM(x)
    while x.right != NIL
        x = x.right
    return x

TREE-INSERT(T, z)
    x = T.root
    y = NIL
    while x != NIL
        y = x
        if z.key < x.key
            x = x.left
        else x = x.right
    z.p = y
    if y == NIL
        T.root = z
    else if z.key < y.key
        y.left = z
    else y.right = z

TRANSPLANT(T, u, v)
    if u.p == NIL
        T.root = v
    else if u == u.p.left
        u.p.left = v
    else u.p.right = v
    if v != NIL
        v.p = u.p

TREE-DELETE(T, z)
    if z.left == NIL
        TRANSPLANT(T, z, z.right)
    else if z.right == NIL
        TRANSPLANT(T, z, z.left)
    else y = TREE-MINIMUM(z.right)
        if y != z.right
            TRANSPLANT(T, y, y.right)
            y.right = z.right
            y.right.p = y
        TRANSPLANT(T, z, y);
        y.left = z.left
        y.left.p = y

CUT-ROD(p, n)
    if n == 0
        return 0
    q = -$\infty$
    for i = 1 to n
        q = max(q, p[i] + CUT-ROD(p, n - i))
    return q

MEMOIZED-CUT-ROD(p, n)
    let r[0:n] be a new array
    for i = 0 to n
        r[i] = -$\infty$
    return MEMOIZED-CUT-ROD-AUX(p, n, r)

MEMOIZED-CUT-ROD-AUX(p, n, r)
    if r[n] >= 0
        return r[n]
    if n == 0
        q = 0
    else q = -$\infty$
        for i = 1 to n
            q = max(q, p[i] + MEMOIZED-CUT-ROD(p, n - i, r))
    r[n] = q
    return q

BOTTOM-UP-CUT-ROD(p, n)
    let r[0:n] be a new array
    r[0] = 0
    for j = 1 to n
        q = -$\infty$
        for i = 1 to j
            q = max(q, p[i] + r[j - i])
        r[j] = q
    return r[n]

let prices[1:10] be a new array
prices[1] = 1
prices[2] = 5
prices[3] = 8
prices[4] = 9
prices[5] = 12
prices[6] = 17
prices[7] = 17
prices[8] = 20
prices[9] = 24
prices[10] = 30
n = 4
max-price = CUT-ROD(prices, n)
print max-price

// Priority Queues
LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

PARENT(i)
    return i / 2

INSERT(Q, u)
    Q.heap-size = Q.heap-size + 1
    Q[Q.heap-size] = u
    DECREASE-KEY(Q, u, u.d)

MIN-HEAPIFY(Q, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= Q.heap-size and Q[l].d < Q[i].d
        smallest = l
    else
        smallest = i
    if r <= Q.heap-size and Q[r].d < Q[smallest].d
        smallest = r
    if smallest != i
        exchange Q[i] with Q[smallest]
        MIN-HEAPIFY(Q, smallest)

EXTRACT-MIN(Q)
    min = Q[1]
    Q[1] = Q[Q.heap-size]
    Q.heap-size = Q.heap-size - 1
    MIN-HEAPIFY(Q, 1)
    return min

DECREASE-KEY(Q, v, k)
    for i = 1 to Q.heap-size
        // key will have already been adjusted by RELAX
        if Q[i].key == v.key
            Q[i].d = k
            exchange Q[i] with Q[1]
            MIN-HEAPIFY(Q, 1)

INITIALIZE-SINGLE-SOURCE(G, s)
    for each vertex v in G.V
        v.d = $\infty$
        v.$\pi$ = NIL
    s.d = 0

RELAX(u, v, w)
    if v.d > u.d + w(u, v)
        v.d = u.d + w(u, v)
        v.$\pi$ = u
        return TRUE
    return FALSE

SET-UNION(s, v)
    return s + v

DIJKSTRA(G, w, s)
    INITIALIZE-SINGLE-SOURCE(G, s);
    let S be a new set
    let Q[len(G.V)] be a new priorityqueue
    for each vertex v in G.V
        INSERT(Q, v)
    while Q
        u = EXTRACT-MIN(Q)
        S = S | {u}
        for each vertex v in G.Adj(u)
            did-decrease = RELAX(u, v, w)
            if did-decrease
                DECREASE-KEY(Q, v, v.d)


DIJKSTRA-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 10
    adj-mat[1][4] = 5
    adj-mat[2][3] = 1
    adj-mat[2][4] = 2
    adj-mat[3][5] = 4
    adj-mat[4][2] = 3
    adj-mat[4][3] = 9
    adj-mat[4][5] = 2
    adj-mat[5][3] = 6

    w(u, v)
        return adj-mat[u.key][v.key]

    let G[adj-mat] be a new graph
    DIJKSTRA(G, w, G.V[1])
    print "done"

    for each u in G.V
        print u

DIJKSTRA-EXAMPLE()

// Queue operations
ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

BFS(G, s)
    // for each vertex u in G.V - {s}
    for each vertex u in G.V
        if u == s
            continue
        u.color = WHITE
        u.d = $\infty$
        u.$\pi$ = NIL
    s.color = GRAY
    s.d = 0
    s.$\pi$ = NIL
    let Q[len(G.V) + 1] be a new queue
    ENQUEUE(Q, s)
    while len(Q) > 0
        u = DEQUEUE(Q)
        for each vertex v in G.Adj(u)
            if v.color == WHITE
                v.color = GRAY
                v.d = u.d + 1
                v.$\pi$ = u
                ENQUEUE(Q, v)
        u.color = BLACK

BFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    BFS(G, G.V[1])
    for each u in G.V
        print u

DFS(G)
    for each vertex u in G.V
        u.color = WHITE
        u.$\pi$ = NIL
    time = 0
    for each vertex u in G.V
        if u.color == WHITE
            DFS-VISIT(G, u, time)

DFS-VISIT(G, u, time)
    time = time + 1
    u.d = time
    u.color = GRAY
    for each vertex v in G.Adj(u)
        if v.color == WHITE
            v.$\pi$ = u
            DFS-VISIT(G, v, time)
    u.color = BLACK
    time = time + 1
    u.f = time

DFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    DFS(G)
    for each u in G.V
        print str(u) + " f=" + str(u.f)

BUBBLESORT(A, n)
    for i = 1 to n - 1
        for j = n downto i + 1
            if A[j] < A[j - 1]
                exchange A[j] with A[j - 1]

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

A = [5, 4, 3, 2, 1]
print A
INSERTION-SORT(A, 5)
print A

MERGE(A, p, q, r)
    // this is a comment
    n$_L$ = q - p + 1
    n$_R$ = r - q
    let L[0:n$_L$ - 1] and R[0:n$_R$ - 1] be new arrays
    for i = 0 to n$_L$ - 1
        L[i] = A[p + i]
    for j = 0 to n$_R$ - 1
        R[j] = A[q + j + 1]
    i = 0
    j = 0
    k = p
    while i < n$_L$ and j < n$_R$
        if L[i] <= R[j]
            A[k] = L[i]
            i = i + 1
        else A[k] = R[j]
            j = j + 1
        k = k + 1
    while i < n$_L$
        A[k] = L[i]
        i = i + 1
        k = k + 1
    while j < n$_R$
        A[k] = R[j]
        j = j + 1
        k = k + 1

let A[1:10] be a new array
for i = 1 to 5
    A[i] = i + 10
    A[i + 5] = i + 10

print A
MERGE(A, 1, 5, 10)
print A

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

let A$_l$[1:5] be a new array
for i = 1 to 5
    A$_l$[i] = 6 - i
print A$_l$
INSERTION-SORT(A$_l$, 5)
print A$_l$

MATRIX-MULTIPLY(A, B, C, n)
    for i = 1 to n
        for j = 1 to n
            for k = 1 to n
                C[i][j] = C[i][j] + A[i][k] * B[k][j]

ONLINE-MAXIMUM(k, n)
    best-score = -infinity
    for i = 1 to k
        if score(i) > best-score
            best-score = score(i)
    for i = k + 1 to n
        if score(i) > best-score
            return i
    return n

PERMUTE-BY-CYCLE(A, n)
    let B[1:n] be a new array
    offset = RANDOM(1, n)
    for i = 1 to n
        dest = i + offset
        if dest > n
            dest = dest - n
        B[dest] = A[i]
    return B

let A[1:20] be a new array
for i = 1 to 20
    A[i] = 10 * i + RANDOM(0, 9)
print A
B = PERMUTE-BY-CYCLE(A, 20)
print B

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.1
PARENT(i)
    // could alternatively use i \\ 2
    return floor(i / 2)

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MIN-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] < A[i]
        smallest = l
    else
        smallest = i
    if r <= A.heap-size and A[r] < A[smallest]
        smallest = r
    if smallest != i
        exchange A[i] with A[smallest]
        MIN-HEAPIFY(A, smallest)

MIN-HEAP-MINIMUM(A)
    if A.heap-size < 1
        error "heap underflow"
    return A[1]

BUILD-MIN-HEAP(A, n)
    A.heap-size = n
    for i = PARENT(n) downto 1
        MIN-HEAPIFY(A, i)

EXTRACT-MIN(A)
    min = A[1]
    A[1] = A[A.heap-size]
    A.heap-size = A.heap-size - 1
    MIN-HEAPIFY(A, 1)
    return min

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MAX-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] > A[i]
        largest = l
    else largest = i
    if r <= A.heap-size and A[r] > A[largest]
        largest = r
    if largest != i
        exchange A[i] with A[largest]
        MAX-HEAPIFY(A, largest)

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.4
HEAPSORT(A, n)
    BUILD-MAX-HEAP(A, n)
    for i = n downto 2
        exchange A[1] with A[i]
        A.heap-size = A.heap-size - 1
        MAX-HEAPIFY(A, 1)

PARTITION(A, p, r)
    x = A[r]
    i = p - 1
    for j = p to r - 1
        if A[j] <= x
            i = i + 1
            exchange A[i] with A[j]
    exchange A[i + 1] with A[r]
    return i + 1

QUICKSORT(A, p, r)
    if p < r
        q = PARTITION(A, p, r)
        QUICKSORT(A, p, q - 1)
        QUICKSORT(A, q + 1, r)

COUNTING-SORT(A, n, k)
    let B[1:n] and C[0:k] be new arrays
    for i = 0 to k
        C[i] = 0
    for j = 1 to n
        C[A[j]] = C[A[j]] + 1
    // C[i] now contains the number of elements equal to i
    for i = 1 to k
        C[i] = C[i] + C[i - 1]
    // C[i] now contains the number of elements less than or equal to i
    // Copy A to B, starting from the enf od A
    for j = n downto 1
        B[C[A[j]]] = A[j]
        C[A[j]] = C[A[j]] - 1 // to handle duplicate values
    return B

LIST-INSERT(x, y)
    x.next = y.next
    x.prev = y
    if y.next != NIL
        y.next.prev = x
    y.next = x

LIST-INSERT'(x, y)
    x.next = y.next
    x.prev = y
    y.next.prev = x
    y.next = x

LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-SEARCH'(L, k)
    L.nil.key = k
    x = L.nil.next
    while x.key != k
        x = x.next
    if x == L.nil
        return NIL
    else return x

ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

STACK-EMPTY(S)
    if S.top == 0
        return TRUE
    else return FALSE

PUSH(S, x)
    if S.top == S.size
        error "overflow"
    else
        S.top = S.top + 1
        S[S.top] = x

POP(S)
    if STACK-EMPTY(S)
        error "underflow"
    else
        S.top = S.top - 1
        return S[S.top + 1]

// section 11.2

// linked list algorithms
LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-DELETE(L, x)
    if x.prev != NIL
        x.prev.next = x.next
    else L.head = x.next
    if x.next != NIL
        x.next.prev = x.prev

// dummy hash function impl.
h(x)
    return x

CHAINED-HASH-INSERT(T, k, x)
    let N[NIL,NIL,k,x] be a new listnode
    LIST-PREPEND(T[h(N.key)], N)

CHAINED-HASH-SEARCH(T, k)
    found = LIST-SEARCH(T[h(k)], k)
    if found != NIL
        return found.value
    else return NIL

CHAINED-HASH-DELETE(T, k)
    subject = LIST-SEARCH(T[h(k)], k)
    LIST-DELETE(T[h(k)], subject)

INORDER-TREE-WALK(x)
    if x != NIL
        INORDER-TREE-WALK(x.left)
        print x.key
        INORDER-TREE-WALK(x.right)

TREE-SEARCH(x, k)
    if x == NIL or k == x.key
        return x
    if k < x.key
        return TREE-SEARCH(x.left, k)
    else return TREE-SEARCH(x.right, k)

ITERATIVE-TREE-SEARCH(x, k)
    while x != NIL and k != x.key
        if k < x.key
            x = x.left
        else x = x.right
    return x

TREE-MINIMUM(x)
    while x.left != NIL
        x = x.left
    return x

TREE-MAXIMUM(x)
    while x.right != NIL
        x = x.right
    return x

TREE-INSERT(T, z)
    x = T.root
    y = NIL
    while x != NIL
        y = x
        if z.key < x.key
            x = x.left
        else x = x.right
    z.p = y
    if y == NIL
        T.root = z
    else if z.key < y.key
        y.left = z
    else y.right = z

TRANSPLANT(T, u, v)
    if u.p == NIL
        T.root = v
    else if u == u.p.left
        u.p.left = v
    else u.p.right = v
    if v != NIL
        v.p = u.p

TREE-DELETE(T, z)
    if z.left == NIL
        TRANSPLANT(T, z, z.right)
    else if z.right == NIL
        TRANSPLANT(T, z, z.left)
    else y = TREE-MINIMUM(z.right)
        if y != z.right
            TRANSPLANT(T, y, y.right)
            y.right = z.right
            y.right.p = y
        TRANSPLANT(T, z, y);
        y.left = z.left
        y.left.p = y

CUT-ROD(p, n)
    if n == 0
        return 0
    q = -$\infty$
    for i = 1 to n
        q = max(q, p[i] + CUT-ROD(p, n - i))
    return q

MEMOIZED-CUT-ROD(p, n)
    let r[0:n] be a new array
    for i = 0 to n
        r[i] = -$\infty$
    return MEMOIZED-CUT-ROD-AUX(p, n, r)

MEMOIZED-CUT-ROD-AUX(p, n, r)
    if r[n] >= 0
        return r[n]
    if n == 0
        q = 0
    else q = -$\infty$
        for i = 1 to n
            q = max(q, p[i] + MEMOIZED-CUT-ROD(p, n - i, r))
    r[n] = q
    return q

BOTTOM-UP-CUT-ROD(p, n)
    let r[0:n] be a new array
    r[0] = 0
    for j = 1 to n
        q = -$\infty$
        for i = 1 to j
            q = max(q, p[i] + r[j - i])
        r[j] = q
    return r[n]

let prices[1:10] be a new array
prices[1] = 1
prices[2] = 5
prices[3] = 8
prices[4] = 9
prices[5] = 12
prices[6] = 17
prices[7] = 17
prices[8] = 20
prices[9] = 24
prices[10] = 30
n = 4
max-price = CUT-ROD(prices, n)
print max-price

// Priority Queues
LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

PARENT(i)
    return i / 2

INSERT(Q, u)
    Q.heap-size = Q.heap-size + 1
    Q[Q.heap-size] = u
    DECREASE-KEY(Q, u, u.d)

MIN-HEAPIFY(Q, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= Q.heap-size and Q[l].d < Q[i].d
        smallest = l
    else
        smallest = i
    if r <= Q.heap-size and Q[r].d < Q[smallest].d
        smallest = r
    if smallest != i
        exchange Q[i] with Q[smallest]
        MIN-HEAPIFY(Q, smallest)

EXTRACT-MIN(Q)
    min = Q[1]
    Q[1] = Q[Q.heap-size]
    Q.heap-size = Q.heap-size - 1
    MIN-HEAPIFY(Q, 1)
    return min

DECREASE-KEY(Q, v, k)
    for i = 1 to Q.heap-size
        // key will have already been adjusted by RELAX
        if Q[i].key == v.key
            Q[i].d = k
            exchange Q[i] with Q[1]
            MIN-HEAPIFY(Q, 1)

INITIALIZE-SINGLE-SOURCE(G, s)
    for each vertex v in G.V
        v.d = $\infty$
        v.$\pi$ = NIL
    s.d = 0

RELAX(u, v, w)
    if v.d > u.d + w(u, v)
        v.d = u.d + w(u, v)
        v.$\pi$ = u
        return TRUE
    return FALSE

SET-UNION(s, v)
    return s + v

DIJKSTRA(G, w, s)
    INITIALIZE-SINGLE-SOURCE(G, s);
    let S be a new set
    let Q[len(G.V)] be a new priorityqueue
    for each vertex v in G.V
        INSERT(Q, v)
    while Q
        u = EXTRACT-MIN(Q)
        S = S | {u}
        for each vertex v in G.Adj(u)
            did-decrease = RELAX(u, v, w)
            if did-decrease
                DECREASE-KEY(Q, v, v.d)


DIJKSTRA-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 10
    adj-mat[1][4] = 5
    adj-mat[2][3] = 1
    adj-mat[2][4] = 2
    adj-mat[3][5] = 4
    adj-mat[4][2] = 3
    adj-mat[4][3] = 9
    adj-mat[4][5] = 2
    adj-mat[5][3] = 6

    w(u, v)
        return adj-mat[u.key][v.key]

    let G[adj-mat] be a new graph
    DIJKSTRA(G, w, G.V[1])
    print "done"

    for each u in G.V
        print u

DIJKSTRA-EXAMPLE()

// Queue operations
ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

BFS(G, s)
    // for each vertex u in G.V - {s}
    for each vertex u in G.V
        if u == s
            continue
        u.color = WHITE
        u.d = $\infty$
        u.$\pi$ = NIL
    s.color = GRAY
    s.d = 0
    s.$\pi$ = NIL
    let Q[len(G.V) + 1] be a new queue
    ENQUEUE(Q, s)
    while len(Q) > 0
        u = DEQUEUE(Q)
        for each vertex v in G.Adj(u)
            if v.color == WHITE
                v.color = GRAY
                v.d = u.d + 1
                v.$\pi$ = u
                ENQUEUE(Q, v)
        u.color = BLACK

BFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    BFS(G, G.V[1])
    for each u in G.V
        print u

DFS(G)
    for each vertex u in G.V
        u.color = WHITE
        u.$\pi$ = NIL
    time = 0
    for each vertex u in G.V
        if u.color == WHITE
            DFS-VISIT(G, u, time)

DFS-VISIT(G, u, time)
    time = time + 1
    u.d = time
    u.color = GRAY
    for each vertex v in G.Adj(u)
        if v.color == WHITE
            v.$\pi$ = u
            DFS-VISIT(G, v, time)
    u.color = BLACK
    time = time + 1
    u.f = time

DFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    DFS(G)
    for each u in G.V
        print str(u) + " f=" + str(u.f)

BUBBLESORT(A, n)
    for i = 1 to n - 1
        for j = n downto i + 1
            if A[j] < A[j - 1]
                exchange A[j] with A[j - 1]

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

A = [5, 4, 3, 2, 1]
print A
INSERTION-SORT(A, 5)
print A

MERGE(A, p, q, r)
    // this is a comment
    n$_L$ = q - p + 1
    n$_R$ = r - q
    let L[0:n$_L$ - 1] and R[0:n$_R$ - 1] be new arrays
    for i = 0 to n$_L$ - 1
        L[i] = A[p + i]
    for j = 0 to n$_R$ - 1
        R[j] = A[q + j + 1]
    i = 0
    j = 0
    k = p
    while i < n$_L$ and j < n$_R$
        if L[i] <= R[j]
            A[k] = L[i]
            i = i + 1
        else A[k] = R[j]
            j = j + 1
        k = k + 1
    while i < n$_L$
        A[k] = L[i]
        i = i + 1
        k = k + 1
    while j < n$_R$
        A[k] = R[j]
        j = j + 1
        k = k + 1

let A[1:10] be a new array
for i = 1 to 5
    A[i] = i + 10
    A[i + 5] = i + 10

print A
MERGE(A, 1, 5, 10)
print A

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

let A$_l$[1:5] be a new array
for i = 1 to 5
    A$_l$[i] = 6 - i
print A$_l$
INSERTION-SORT(A$_l$, 5)
print A$_l$

MATRIX-MULTIPLY(A, B, C, n)
    for i = 1 to n
        for j = 1 to n
            for k = 1 to n
                C[i][j] = C[i][j] + A[i][k] * B[k][j]

ONLINE-MAXIMUM(k, n)
    best-score = -infinity
    for i = 1 to k
        if score(i) > best-score
            best-score = score(i)
    for i = k + 1 to n
        if score(i) > best-score
            return i
    return n

PERMUTE-BY-CYCLE(A, n)
    let B[1:n] be a new array
    offset = RANDOM(1, n)
    for i = 1 to n
        dest = i + offset
        if dest > n
            dest = dest - n
        B[dest] = A[i]
    return B

let A[1:20] be a new array
for i = 1 to 20
    A[i] = 10 * i + RANDOM(0, 9)
print A
B = PERMUTE-BY-CYCLE(A, 20)
print B

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.1
PARENT(i)
    // could alternatively use i \\ 2
    return floor(i / 2)

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MIN-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] < A[i]
        smallest = l
    else
        smallest = i
    if r <= A.heap-size and A[r] < A[smallest]
        smallest = r
    if smallest != i
        exchange A[i] with A[smallest]
        MIN-HEAPIFY(A, smallest)

MIN-HEAP-MINIMUM(A)
    if A.heap-size < 1
        error "heap underflow"
    return A[1]

BUILD-MIN-HEAP(A, n)
    A.heap-size = n
    for i = PARENT(n) downto 1
        MIN-HEAPIFY(A, i)

EXTRACT-MIN(A)
    min = A[1]
    A[1] = A[A.heap-size]
    A.heap-size = A.heap-size - 1
    MIN-HEAPIFY(A, 1)
    return min

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MAX-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] > A[i]
        largest = l
    else largest = i
    if r <= A.heap-size and A[r] > A[largest]
        largest = r
    if largest != i
        exchange A[i] with A[largest]
        MAX-HEAPIFY(A, largest)

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.4
HEAPSORT(A, n)
    BUILD-MAX-HEAP(A, n)
    for i = n downto 2
        exchange A[1] with A[i]
        A.heap-size = A.heap-size - 1
        MAX-HEAPIFY(A, 1)

PARTITION(A, p, r)
    x = A[r]
    i = p - 1
    for j = p to r - 1
        if A[j] <= x
            i = i + 1
            exchange A[i] with A[j]
    exchange A[i + 1] with A[r]
    return i + 1

QUICKSORT(A, p, r)
    if p < r
        q = PARTITION(A, p, r)
        QUICKSORT(A, p, q - 1)
        QUICKSORT(A, q + 1, r)

COUNTING-SORT(A, n, k)
    let B[1:n] and C[0:k] be new arrays
    for i = 0 to k
        C[i] = 0
    for j = 1 to n
        C[A[j]] = C[A[j]] + 1
    // C[i] now contains the number of elements equal to i
    for i = 1 to k
        C[i] = C[i] + C[i - 1]
    // C[i] now contains the number of elements less than or equal to i
    // Copy A to B, starting from the enf od A
    for j = n downto 1
        B[C[A[j]]] = A[j]
        C[A[j]] = C[A[j]] - 1 // to handle duplicate values
    return B

LIST-INSERT(x, y)
    x.next = y.next
    x.prev = y
    if y.next != NIL
        y.next.prev = x
    y.next = x

LIST-INSERT'(x, y)
    x.next = y.next
    x.prev = y
    y.next.prev = x
    y.next = x

LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-SEARCH'(L, k)
    L.nil.key = k
    x = L.nil.next
    while x.key != k
        x = x.next
    if x == L.nil
        return NIL
    else return x

ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

STACK-EMPTY(S)
    if S.top == 0
        return TRUE
    else return FALSE

PUSH(S, x)
    if S.top == S.size
        error "overflow"
    else
        S.top = S.top + 1
        S[S.top] = x

POP(S)
    if STACK-EMPTY(S)
        error "underflow"
    else
        S.top = S.top - 1
        return S[S.top + 1]

// section 11.2

// linked list algorithms
LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-DELETE(L, x)
    if x.prev != NIL
        x.prev.next = x.next
    else L.head = x.next
    if x.next != NIL
        x.next.prev = x.prev

// dummy hash function impl.
h(x)
    return x

CHAINED-HASH-INSERT(T, k, x)
    let N[NIL,NIL,k,x] be a new listnode
    LIST-PREPEND(T[h(N.key)], N)

CHAINED-HASH-SEARCH(T, k)
    found = LIST-SEARCH(T[h(k)], k)
    if found != NIL
        return found.value
    else return NIL

CHAINED-HASH-DELETE(T, k)
    subject = LIST-SEARCH(T[h(k)], k)
    LIST-DELETE(T[h(k)], subject)

INORDER-TREE-WALK(x)
    if x != NIL
        INORDER-TREE-WALK(x.left)
        print x.key
        INORDER-TREE-WALK(x.right)

TREE-SEARCH(x, k)
    if x == NIL or k == x.key
        return x
    if k < x.key
        return TREE-SEARCH(x.left, k)
    else return TREE-SEARCH(x.right, k)

ITERATIVE-TREE-SEARCH(x, k)
    while x != NIL and k != x.key
        if k < x.key
            x = x.left
        else x = x.right
    return x

TREE-MINIMUM(x)
    while x.left != NIL
        x = x.left
    return x

TREE-MAXIMUM(x)
    while x.right != NIL
        x = x.right
    return x

TREE-INSERT(T, z)
    x = T.root
    y = NIL
    while x != NIL
        y = x
        if z.key < x.key
            x = x.left
        else x = x.right
    z.p = y
    if y == NIL
        T.root = z
    else if z.key < y.key
        y.left = z
    else y.right = z

TRANSPLANT(T, u, v)
    if u.p == NIL
        T.root = v
    else if u == u.p.left
        u.p.left = v
    else u.p.right = v
    if v != NIL
        v.p = u.p

TREE-DELETE(T, z)
    if z.left == NIL
        TRANSPLANT(T, z, z.right)
    else if z.right == NIL
        TRANSPLANT(T, z, z.left)
    else y = TREE-MINIMUM(z.right)
        if y != z.right
            TRANSPLANT(T, y, y.right)
            y.right = z.right
            y.right.p = y
        TRANSPLANT(T, z, y);
        y.left = z.left
        y.left.p = y

CUT-ROD(p, n)
    if n == 0
        return 0
    q = -$\infty$
    for i = 1 to n
        q = max(q, p[i] + CUT-ROD(p, n - i))
    return q

MEMOIZED-CUT-ROD(p, n)
    let r[0:n] be a new array
    for i = 0 to n
        r[i] = -$\infty$
    return MEMOIZED-CUT-ROD-AUX(p, n, r)

MEMOIZED-CUT-ROD-AUX(p, n, r)
    if r[n] >= 0
        return r[n]
    if n == 0
        q = 0
    else q = -$\infty$
        for i = 1 to n
            q = max(q, p[i] + MEMOIZED-CUT-ROD(p, n - i, r))
    r[n] = q
    return q

BOTTOM-UP-CUT-ROD(p, n)
    let r[0:n] be a new array
    r[0] = 0
    for j = 1 to n
        q = -$\infty$
        for i = 1 to j
            q = max(q, p[i] + r[j - i])
        r[j] = q
    return r[n]

let prices[1:10] be a new array
prices[1] = 1
prices[2] = 5
prices[3] = 8
prices[4] = 9
prices[5] = 12
prices[6] = 17
prices[7] = 17
prices[8] = 20
prices[9] = 24
prices[10] = 30
n = 4
max-price = CUT-ROD(prices, n)
print max-price

// Priority Queues
LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

PARENT(i)
    return i / 2

INSERT(Q, u)
    Q.heap-size = Q.heap-size + 1
    Q[Q.heap-size] = u
    DECREASE-KEY(Q, u, u.d)

MIN-HEAPIFY(Q, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= Q.heap-size and Q[l].d < Q[i].d
        smallest = l
    else
        smallest = i
    if r <= Q.heap-size and Q[r].d < Q[smallest].d
        smallest = r
    if smallest != i
        exchange Q[i] with Q[smallest]
        MIN-HEAPIFY(Q, smallest)

EXTRACT-MIN(Q)
    min = Q[1]
    Q[1] = Q[Q.heap-size]
    Q.heap-size = Q.heap-size - 1
    MIN-HEAPIFY(Q, 1)
    return min

DECREASE-KEY(Q, v, k)
    for i = 1 to Q.heap-size
        // key will have already been adjusted by RELAX
        if Q[i].key == v.key
            Q[i].d = k
            exchange Q[i] with Q[1]
            MIN-HEAPIFY(Q, 1)

INITIALIZE-SINGLE-SOURCE(G, s)
    for each vertex v in G.V
        v.d = $\infty$
        v.$\pi$ = NIL
    s.d = 0

RELAX(u, v, w)
    if v.d > u.d + w(u, v)
        v.d = u.d + w(u, v)
        v.$\pi$ = u
        return TRUE
    return FALSE

SET-UNION(s, v)
    return s + v

DIJKSTRA(G, w, s)
    INITIALIZE-SINGLE-SOURCE(G, s);
    let S be a new set
    let Q[len(G.V)] be a new priorityqueue
    for each vertex v in G.V
        INSERT(Q, v)
    while Q
        u = EXTRACT-MIN(Q)
        S = S | {u}
        for each vertex v in G.Adj(u)
            did-decrease = RELAX(u, v, w)
            if did-decrease
                DECREASE-KEY(Q, v, v.d)


DIJKSTRA-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 10
    adj-mat[1][4] = 5
    adj-mat[2][3] = 1
    adj-mat[2][4] = 2
    adj-mat[3][5] = 4
    adj-mat[4][2] = 3
    adj-mat[4][3] = 9
    adj-mat[4][5] = 2
    adj-mat[5][3] = 6

    w(u, v)
        return adj-mat[u.key][v.key]

    let G[adj-mat] be a new graph
    DIJKSTRA(G, w, G.V[1])
    print "done"

    for each u in G.V
        print u

DIJKSTRA-EXAMPLE()

// Queue operations
ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

BFS(G, s)
    // for each vertex u in G.V - {s}
    for each vertex u in G.V
        if u == s
            continue
        u.color = WHITE
        u.d = $\infty$
        u.$\pi$ = NIL
    s.color = GRAY
    s.d = 0
    s.$\pi$ = NIL
    let Q[len(G.V) + 1] be a new queue
    ENQUEUE(Q, s)
    while len(Q) > 0
        u = DEQUEUE(Q)
        for each vertex v in G.Adj(u)
            if v.color == WHITE
                v.color = GRAY
                v.d = u.d + 1
                v.$\pi$ = u
                ENQUEUE(Q, v)
        u.color = BLACK

BFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    BFS(G, G.V[1])
    for each u in G.V
        print u

DFS(G)
    for each vertex u in G.V
        u.color = WHITE
        u.$\pi$ = NIL
    time = 0
    for each vertex u in G.V
        if u.color == WHITE
            DFS-VISIT(G, u, time)

DFS-VISIT(G, u, time)
    time = time + 1
    u.d = time
    u.color = GRAY
    for each vertex v in G.Adj(u)
        if v.color == WHITE
            v.$\pi$ = u
            DFS-VISIT(G, v, time)
    u.color = BLACK
    time = time + 1
    u.f = time

DFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    DFS(G)
    for each u in G.V
        print str(u) + " f=" + str(u.f)

BUBBLESORT(A, n)
    for i = 1 to n - 1
        for j = n downto i + 1
            if A[j] < A[j - 1]
                exchange A[j] with A[j - 1]

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

A = [5, 4, 3, 2, 1]
print A
INSERTION-SORT(A, 5)
print A

MERGE(A, p, q, r)
    // this is a comment
    n$_L$ = q - p + 1
    n$_R$ = r - q
    let L[0:n$_L$ - 1] and R[0:n$_R$ - 1] be new arrays
    for i = 0 to n$_L$ - 1
        L[i] = A[p + i]
    for j = 0 to n$_R$ - 1
        R[j] = A[q + j + 1]
    i = 0
    j = 0
    k = p
    while i < n$_L$ and j < n$_R$
        if L[i] <= R[j]
            A[k] = L[i]
            i = i + 1
        else A[k] = R[j]
            j = j + 1
        k = k + 1
    while i < n$_L$
        A[k] = L[i]
        i = i + 1
        k = k + 1
    while j < n$_R$
        A[k] = R[j]
        j = j + 1
        k = k + 1

let A[1:10] be a new array
for i = 1 to 5
    A[i] = i + 10
    A[i + 5] = i + 10

print A
MERGE(A, 1, 5, 10)
print A

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

let A$_l$[1:5] be a new array
for i = 1 to 5
    A$_l$[i] = 6 - i
print A$_l$
INSERTION-SORT(A$_l$, 5)
print A$_l$

MATRIX-MULTIPLY(A, B, C, n)
    for i = 1 to n
        for j = 1 to n
            for k = 1 to n
                C[i][j] = C[i][j] + A[i][k] * B[k][j]

ONLINE-MAXIMUM(k, n)
    best-score = -infinity
    for i = 1 to k
        if score(i) > best-score
            best-score = score(i)
    for i = k + 1 to n
        if score(i) > best-score
            return i
    return n

PERMUTE-BY-CYCLE(A, n)
    let B[1:n] be a new array
    offset = RANDOM(1, n)
    for i = 1 to n
        dest = i + offset
        if dest > n
            dest = dest - n
        B[dest] = A[i]
    return B

let A[1:20] be a new array
for i = 1 to 20
    A[i] = 10 * i + RANDOM(0, 9)
print A
B = PERMUTE-BY-CYCLE(A, 20)
print B

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.1
PARENT(i)
    // could alternatively use i \\ 2
    return floor(i / 2)

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MIN-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] < A[i]
        smallest = l
    else
        smallest = i
    if r <= A.heap-size and A[r] < A[smallest]
        smallest = r
    if smallest != i
        exchange A[i] with A[smallest]
        MIN-HEAPIFY(A, smallest)

MIN-HEAP-MINIMUM(A)
    if A.heap-size < 1
        error "heap underflow"
    return A[1]

BUILD-MIN-HEAP(A, n)
    A.heap-size = n
    for i = PARENT(n) downto 1
        MIN-HEAPIFY(A, i)

EXTRACT-MIN(A)
    min = A[1]
    A[1] = A[A.heap-size]
    A.heap-size = A.heap-size - 1
    MIN-HEAPIFY(A, 1)
    return min

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MAX-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] > A[i]
        largest = l
    else largest = i
    if r <= A.heap-size and A[r] > A[largest]
        largest = r
    if largest != i
        exchange A[i] with A[largest]
        MAX-HEAPIFY(A, largest)

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.4
HEAPSORT(A, n)
    BUILD-MAX-HEAP(A, n)
    for i = n downto 2
        exchange A[1] with A[i]
        A.heap-size = A.heap-size - 1
        MAX-HEAPIFY(A, 1)

PARTITION(A, p, r)
    x = A[r]
    i = p - 1
    for j = p to r - 1
        if A[j] <= x
            i = i + 1
            exchange A[i] with A[j]
    exchange A[i + 1] with A[r]
    return i + 1

QUICKSORT(A, p, r)
    if p < r
        q = PARTITION(A, p, r)
        QUICKSORT(A, p, q - 1)
        QUICKSORT(A, q + 1, r)

COUNTING-SORT(A, n, k)
    let B[1:n] and C[0:k] be new arrays
    for i = 0 to k
        C[i] = 0
    for j = 1 to n
        C[A[j]] = C[A[j]] + 1
    // C[i] now contains the number of elements equal to i
    for i = 1 to k
        C[i] = C[i] + C[i - 1]
    // C[i] now contains the number of elements less than or equal to i
    // Copy A to B, starting from the enf od A
    for j = n downto 1
        B[C[A[j]]] = A[j]
        C[A[j]] = C[A[j]] - 1 // to handle duplicate values
    return B

LIST-INSERT(x, y)
    x.next = y.next
    x.prev = y
    if y.next != NIL
        y.next.prev = x
    y.next = x

LIST-INSERT'(x, y)
    x.next = y.next
    x.prev = y
    y.next.prev = x
    y.next = x

LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-SEARCH'(L, k)
    L.nil.key = k
    x = L.nil.next
    while x.key != k
        x = x.next
    if x == L.nil
        return NIL
    else return x

ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

STACK-EMPTY(S)
    if S.top == 0
        return TRUE
    else return FALSE

PUSH(S, x)
    if S.top == S.size
        error "overflow"
    else
        S.top = S.top + 1
        S[S.top] = x

POP(S)
    if STACK-EMPTY(S)
        error "underflow"
    else
        S.top = S.top - 1
        return S[S.top + 1]

// section 11.2

// linked list algorithms
LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-DELETE(L, x)
    if x.prev != NIL
        x.prev.next = x.next
    else L.head = x.next
    if x.next != NIL
        x.next.prev = x.prev

// dummy hash function impl.
h(x)
    return x

CHAINED-HASH-INSERT(T, k, x)
    let N[NIL,NIL,k,x] be a new listnode
    LIST-PREPEND(T[h(N.key)], N)

CHAINED-HASH-SEARCH(T, k)
    found = LIST-SEARCH(T[h(k)], k)
    if found != NIL
        return found.value
    else return NIL

CHAINED-HASH-DELETE(T, k)
    subject = LIST-SEARCH(T[h(k)], k)
    LIST-DELETE(T[h(k)], subject)

INORDER-TREE-WALK(x)
    if x != NIL
        INORDER-TREE-WALK(x.left)
        print x.key
        INORDER-TREE-WALK(x.right)

TREE-SEARCH(x, k)
    if x == NIL or k == x.key
        return x
    if k < x.key
        return TREE-SEARCH(x.left, k)
    else return TREE-SEARCH(x.right, k)

ITERATIVE-TREE-SEARCH(x, k)
    while x != NIL and k != x.key
        if k < x.key
            x = x.left
        else x = x.right
    return x

TREE-MINIMUM(x)
    while x.left != NIL
        x = x.left
    return x

TREE-MAXIMUM(x)
    while x.right != NIL
        x = x.right
    return x

TREE-INSERT(T, z)
    x = T.root
    y = NIL
    while x != NIL
        y = x
        if z.key < x.key
            x = x.left
        else x = x.right
    z.p = y
    if y == NIL
        T.root = z
    else if z.key < y.key
        y.left = z
    else y.right = z

TRANSPLANT(T, u, v)
    if u.p == NIL
        T.root = v
    else if u == u.p.left
        u.p.left = v
    else u.p.right = v
    if v != NIL
        v.p = u.p

TREE-DELETE(T, z)
    if z.left == NIL
        TRANSPLANT(T, z, z.right)
    else if z.right == NIL
        TRANSPLANT(T, z, z.left)
    else y = TREE-MINIMUM(z.right)
        if y != z.right
            TRANSPLANT(T, y, y.right)
            y.right = z.right
            y.right.p = y
        TRANSPLANT(T, z, y);
        y.left = z.left
        y.left.p = y

CUT-ROD(p, n)
    if n == 0
        return 0
    q = -$\infty$
    for i = 1 to n
        q = max(q, p[i] + CUT-ROD(p, n - i))
    return q

MEMOIZED-CUT-ROD(p, n)
    let r[0:n] be a new array
    for i = 0 to n
        r[i] = -$\infty$
    return MEMOIZED-CUT-ROD-AUX(p, n, r)

MEMOIZED-CUT-ROD-AUX(p, n, r)
    if r[n] >= 0
        return r[n]
    if n == 0
        q = 0
    else q = -$\infty$
        for i = 1 to n
            q = max(q, p[i] + MEMOIZED-CUT-ROD(p, n - i, r))
    r[n] = q
    return q

BOTTOM-UP-CUT-ROD(p, n)
    let r[0:n] be a new array
    r[0] = 0
    for j = 1 to n
        q = -$\infty$
        for i = 1 to j
            q = max(q, p[i] + r[j - i])
        r[j] = q
    return r[n]

let prices[1:10] be a new array
prices[1] = 1
prices[2] = 5
prices[3] = 8
prices[4] = 9
prices[5] = 12
prices[6] = 17
prices[7] = 17
prices[8] = 20
prices[9] = 24
prices[10] = 30
n = 4
max-price = CUT-ROD(prices, n)
print max-price

// Priority Queues
LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

PARENT(i)
    return i / 2

INSERT(Q, u)
    Q.heap-size = Q.heap-size + 1
    Q[Q.heap-size] = u
    DECREASE-KEY(Q, u, u.d)

MIN-HEAPIFY(Q, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= Q.heap-size and Q[l].d < Q[i].d
        smallest = l
    else
        smallest = i
    if r <= Q.heap-size and Q[r].d < Q[smallest].d
        smallest = r
    if smallest != i
        exchange Q[i] with Q[smallest]
        MIN-HEAPIFY(Q, smallest)

EXTRACT-MIN(Q)
    min = Q[1]
    Q[1] = Q[Q.heap-size]
    Q.heap-size = Q.heap-size - 1
    MIN-HEAPIFY(Q, 1)
    return min

DECREASE-KEY(Q, v, k)
    for i = 1 to Q.heap-size
        // key will have already been adjusted by RELAX
        if Q[i].key == v.key
            Q[i].d = k
            exchange Q[i] with Q[1]
            MIN-HEAPIFY(Q, 1)

INITIALIZE-SINGLE-SOURCE(G, s)
    for each vertex v in G.V
        v.d = $\infty$
        v.$\pi$ = NIL
    s.d = 0

RELAX(u, v, w)
    if v.d > u.d + w(u, v)
        v.d = u.d + w(u, v)
        v.$\pi$ = u
        return TRUE
    return FALSE

SET-UNION(s, v)
    return s + v

DIJKSTRA(G, w, s)
    INITIALIZE-SINGLE-SOURCE(G, s);
    let S be a new set
    let Q[len(G.V)] be a new priorityqueue
    for each vertex v in G.V
        INSERT(Q, v)
    while Q
        u = EXTRACT-MIN(Q)
        S = S | {u}
        for each vertex v in G.Adj(u)
            did-decrease = RELAX(u, v, w)
            if did-decrease
                DECREASE-KEY(Q, v, v.d)


DIJKSTRA-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 10
    adj-mat[1][4] = 5
    adj-mat[2][3] = 1
    adj-mat[2][4] = 2
    adj-mat[3][5] = 4
    adj-mat[4][2] = 3
    adj-mat[4][3] = 9
    adj-mat[4][5] = 2
    adj-mat[5][3] = 6

    w(u, v)
        return adj-mat[u.key][v.key]

    let G[adj-mat] be a new graph
    DIJKSTRA(G, w, G.V[1])
    print "done"

    for each u in G.V
        print u

DIJKSTRA-EXAMPLE()

// Queue operations
ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

BFS(G, s)
    // for each vertex u in G.V - {s}
    for each vertex u in G.V
        if u == s
            continue
        u.color = WHITE
        u.d = $\infty$
        u.$\pi$ = NIL
    s.color = GRAY
    s.d = 0
    s.$\pi$ = NIL
    let Q[len(G.V) + 1] be a new queue
    ENQUEUE(Q, s)
    while len(Q) > 0
        u = DEQUEUE(Q)
        for each vertex v in G.Adj(u)
            if v.color == WHITE
                v.color = GRAY
                v.d = u.d + 1
                v.$\pi$ = u
                ENQUEUE(Q, v)
        u.color = BLACK

BFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    BFS(G, G.V[1])
    for each u in G.V
        print u

DFS(G)
    for each vertex u in G.V
        u.color = WHITE
        u.$\pi$ = NIL
    time = 0
    for each vertex u in G.V
        if u.color == WHITE
            DFS-VISIT(G, u, time)

DFS-VISIT(G, u, time)
    time = time + 1
    u.d = time
    u.color = GRAY
    for each vertex v in G.Adj(u)
        if v.color == WHITE
            v.$\pi$ = u
            DFS-VISIT(G, v, time)
    u.color = BLACK
    time = time + 1
    u.f = time

DFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    DFS(G)
    for each u in G.V
        print str(u) + " f=" + str(u.f)

BUBBLESORT(A, n)
    for i = 1 to n - 1
        for j = n downto i + 1
            if A[j] < A[j - 1]
                exchange A[j] with A[j - 1]

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

A = [5, 4, 3, 2, 1]
print A
INSERTION-SORT(A, 5)
print A

MERGE(A, p, q, r)
    // this is a comment
    n$_L$ = q - p + 1
    n$_R$ = r - q
    let L[0:n$_L$ - 1] and R[0:n$_R$ - 1] be new arrays
    for i = 0 to n$_L$ - 1
        L[i] = A[p + i]
    for j = 0 to n$_R$ - 1
        R[j] = A[q + j + 1]
    i = 0
    j = 0
    k = p
    while i < n$_L$ and j < n$_R$
        if L[i] <= R[j]
            A[k] = L[i]
            i = i + 1
        else A[k] = R[j]
            j = j + 1
        k = k + 1
    while i < n$_L$
        A[k] = L[i]
        i = i + 1
        k = k + 1
    while j < n$_R$
        A[k] = R[j]
        j = j + 1
        k = k + 1

let A[1:10] be a new array
for i = 1 to 5
    A[i] = i + 10
    A[i + 5] = i + 10

print A
MERGE(A, 1, 5, 10)
print A

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

let A$_l$[1:5] be a new array
for i = 1 to 5
    A$_l$[i] = 6 - i
print A$_l$
INSERTION-SORT(A$_l$, 5)
print A$_l$

MATRIX-MULTIPLY(A, B, C, n)
    for i = 1 to n
        for j = 1 to n
            for k = 1 to n
                C[i][j] = C[i][j] + A[i][k] * B[k][j]

ONLINE-MAXIMUM(k, n)
    best-score = -infinity
    for i = 1 to k
        if score(i) > best-score
            best-score = score(i)
    for i = k + 1 to n
        if score(i) > best-score
            return i
    return n

PERMUTE-BY-CYCLE(A, n)
    let B[1:n] be a new array
    offset = RANDOM(1, n)
    for i = 1 to n
        dest = i + offset
        if dest > n
            dest = dest - n
        B[dest] = A[i]
    return B

let A[1:20] be a new array
for i = 1 to 20
    A[i] = 10 * i + RANDOM(0, 9)
print A
B = PERMUTE-BY-CYCLE(A, 20)
print B

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.1
PARENT(i)
    // could alternatively use i \\ 2
    return floor(i / 2)

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MIN-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] < A[i]
        smallest = l
    else
        smallest = i
    if r <= A.heap-size and A[r] < A[smallest]
        smallest = r
    if smallest != i
        exchange A[i] with A[smallest]
        MIN-HEAPIFY(A, smallest)

MIN-HEAP-MINIMUM(A)
    if A.heap-size < 1
        error "heap underflow"
    return A[1]

BUILD-MIN-HEAP(A, n)
    A.heap-size = n
    for i = PARENT(n) downto 1
        MIN-HEAPIFY(A, i)

EXTRACT-MIN(A)
    min = A[1]
    A[1] = A[A.heap-size]
    A.heap-size = A.heap-size - 1
    MIN-HEAPIFY(A, 1)
    return min

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MAX-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] > A[i]
        largest = l
    else largest = i
    if r <= A.heap-size and A[r] > A[largest]
        largest = r
    if largest != i
        exchange A[i] with A[largest]
        MAX-HEAPIFY(A, largest)

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.4
HEAPSORT(A, n)
    BUILD-MAX-HEAP(A, n)
    for i = n downto 2
        exchange A[1] with A[i]
        A.heap-size = A.heap-size - 1
        MAX-HEAPIFY(A, 1)

PARTITION(A, p, r)
    x = A[r]
    i = p - 1
    for j = p to r - 1
        if A[j] <= x
            i = i + 1
            exchange A[i] with A[j]
    exchange A[i + 1] with A[r]
    return i + 1

QUICKSORT(A, p, r)
    if p < r
        q = PARTITION(A, p, r)
        QUICKSORT(A, p, q - 1)
        QUICKSORT(A, q + 1, r)

COUNTING-SORT(A, n, k)
    let B[1:n] and C[0:k] be new arrays
    for i = 0 to k
        C[i] = 0
    for j = 1 to n
        C[A[j]] = C[A[j]] + 1
    // C[i] now contains the number of elements equal to i
    for i = 1 to k
        C[i] = C[i] + C[i - 1]
    // C[i] now contains the number of elements less than or equal to i
    // Copy A to B, starting from the enf od A
    for j = n downto 1
        B[C[A[j]]] = A[j]
        C[A[j]] = C[A[j]] - 1 // to handle duplicate values
    return B

LIST-INSERT(x, y)
    x.next = y.next
    x.prev = y
    if y.next != NIL
        y.next.prev = x
    y.next = x

LIST-INSERT'(x, y)
    x.next = y.next
    x.prev = y
    y.next.prev = x
    y.next = x

LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-SEARCH'(L, k)
    L.nil.key = k
    x = L.nil.next
    while x.key != k
        x = x.next
    if x == L.nil
        return NIL
    else return x

ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

STACK-EMPTY(S)
    if S.top == 0
        return TRUE
    else return FALSE

PUSH(S, x)
    if S.top == S.size
        error "overflow"
    else
        S.top = S.top + 1
        S[S.top] = x

POP(S)
    if STACK-EMPTY(S)
        error "underflow"
    else
        S.top = S.top - 1
        return S[S.top + 1]

// section 11.2

// linked list algorithms
LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-DELETE(L, x)
    if x.prev != NIL
        x.prev.next = x.next
    else L.head = x.next
    if x.next != NIL
        x.next.prev = x.prev

// dummy hash function impl.
h(x)
    return x

CHAINED-HASH-INSERT(T, k, x)
    let N[NIL,NIL,k,x] be a new listnode
    LIST-PREPEND(T[h(N.key)], N)

CHAINED-HASH-SEARCH(T, k)
    found = LIST-SEARCH(T[h(k)], k)
    if found != NIL
        return found.value
    else return NIL

CHAINED-HASH-DELETE(T, k)
    subject = LIST-SEARCH(T[h(k)], k)
    LIST-DELETE(T[h(k)], subject)

INORDER-TREE-WALK(x)
    if x != NIL
        INORDER-TREE-WALK(x.left)
        print x.key
        INORDER-TREE-WALK(x.right)

TREE-SEARCH(x, k)
    if x == NIL or k == x.key
        return x
    if k < x.key
        return TREE-SEARCH(x.left, k)
    else return TREE-SEARCH(x.right, k)

ITERATIVE-TREE-SEARCH(x, k)
    while x != NIL and k != x.key
        if k < x.key
            x = x.left
        else x = x.right
    return x

TREE-MINIMUM(x)
    while x.left != NIL
        x = x.left
    return x

TREE-MAXIMUM(x)
    while x.right != NIL
        x = x.right
    return x

TREE-INSERT(T, z)
    x = T.root
    y = NIL
    while x != NIL
        y = x
        if z.key < x.key
            x = x.left
        else x = x.right
    z.p = y
    if y == NIL
        T.root = z
    else if z.key < y.key
        y.left = z
    else y.right = z

TRANSPLANT(T, u, v)
    if u.p == NIL
        T.root = v
    else if u == u.p.left
        u.p.left = v
    else u.p.right = v
    if v != NIL
        v.p = u.p

TREE-DELETE(T, z)
    if z.left == NIL
        TRANSPLANT(T, z, z.right)
    else if z.right == NIL
        TRANSPLANT(T, z, z.left)
    else y = TREE-MINIMUM(z.right)
        if y != z.right
            TRANSPLANT(T, y, y.right)
            y.right = z.right
            y.right.p = y
        TRANSPLANT(T, z, y);
        y.left = z.left
        y.left.p = y

CUT-ROD(p, n)
    if n == 0
        return 0
    q = -$\infty$
    for i = 1 to n
        q = max(q, p[i] + CUT-ROD(p, n - i))
    return q

MEMOIZED-CUT-ROD(p, n)
    let r[0:n] be a new array
    for i = 0 to n
        r[i] = -$\infty$
    return MEMOIZED-CUT-ROD-AUX(p, n, r)

MEMOIZED-CUT-ROD-AUX(p, n, r)
    if r[n] >= 0
        return r[n]
    if n == 0
        q = 0
    else q = -$\infty$
        for i = 1 to n
            q = max(q, p[i] + MEMOIZED-CUT-ROD(p, n - i, r))
    r[n] = q
    return q

BOTTOM-UP-CUT-ROD(p, n)
    let r[0:n] be a new array
    r[0] = 0
    for j = 1 to n
        q = -$\infty$
        for i = 1 to j
            q = max(q, p[i] + r[j - i])
        r[j] = q
    return r[n]

let prices[1:10] be a new array
prices[1] = 1
prices[2] = 5
prices[3] = 8
prices[4] = 9
prices[5] = 12
prices[6] = 17
prices[7] = 17
prices[8] = 20
prices[9] = 24
prices[10] = 30
n = 4
max-price = CUT-ROD(prices, n)
print max-price

// Priority Queues
LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

PARENT(i)
    return i / 2

INSERT(Q, u)
    Q.heap-size = Q.heap-size + 1
    Q[Q.heap-size] = u
    DECREASE-KEY(Q, u, u.d)

MIN-HEAPIFY(Q, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= Q.heap-size and Q[l].d < Q[i].d
        smallest = l
    else
        smallest = i
    if r <= Q.heap-size and Q[r].d < Q[smallest].d
        smallest = r
    if smallest != i
        exchange Q[i] with Q[smallest]
        MIN-HEAPIFY(Q, smallest)

EXTRACT-MIN(Q)
    min = Q[1]
    Q[1] = Q[Q.heap-size]
    Q.heap-size = Q.heap-size - 1
    MIN-HEAPIFY(Q, 1)
    return min

DECREASE-KEY(Q, v, k)
    for i = 1 to Q.heap-size
        // key will have already been adjusted by RELAX
        if Q[i].key == v.key
            Q[i].d = k
            exchange Q[i] with Q[1]
            MIN-HEAPIFY(Q, 1)

INITIALIZE-SINGLE-SOURCE(G, s)
    for each vertex v in G.V
        v.d = $\infty$
        v.$\pi$ = NIL
    s.d = 0

RELAX(u, v, w)
    if v.d > u.d + w(u, v)
        v.d = u.d + w(u, v)
        v.$\pi$ = u
        return TRUE
    return FALSE

SET-UNION(s, v)
    return s + v

DIJKSTRA(G, w, s)
    INITIALIZE-SINGLE-SOURCE(G, s);
    let S be a new set
    let Q[len(G.V)] be a new priorityqueue
    for each vertex v in G.V
        INSERT(Q, v)
    while Q
        u = EXTRACT-MIN(Q)
        S = S | {u}
        for each vertex v in G.Adj(u)
            did-decrease = RELAX(u, v, w)
            if did-decrease
                DECREASE-KEY(Q, v, v.d)


DIJKSTRA-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 10
    adj-mat[1][4] = 5
    adj-mat[2][3] = 1
    adj-mat[2][4] = 2
    adj-mat[3][5] = 4
    adj-mat[4][2] = 3
    adj-mat[4][3] = 9
    adj-mat[4][5] = 2
    adj-mat[5][3] = 6

    w(u, v)
        return adj-mat[u.key][v.key]

    let G[adj-mat] be a new graph
    DIJKSTRA(G, w, G.V[1])
    print "done"

    for each u in G.V
        print u

DIJKSTRA-EXAMPLE()

// Queue operations
ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

BFS(G, s)
    // for each vertex u in G.V - {s}
    for each vertex u in G.V
        if u == s
            continue
        u.color = WHITE
        u.d = $\infty$
        u.$\pi$ = NIL
    s.color = GRAY
    s.d = 0
    s.$\pi$ = NIL
    let Q[len(G.V) + 1] be a new queue
    ENQUEUE(Q, s)
    while len(Q) > 0
        u = DEQUEUE(Q)
        for each vertex v in G.Adj(u)
            if v.color == WHITE
                v.color = GRAY
                v.d = u.d + 1
                v.$\pi$ = u
                ENQUEUE(Q, v)
        u.color = BLACK

BFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    BFS(G, G.V[1])
    for each u in G.V
        print u

DFS(G)
    for each vertex u in G.V
        u.color = WHITE
        u.$\pi$ = NIL
    time = 0
    for each vertex u in G.V
        if u.color == WHITE
            DFS-VISIT(G, u, time)

DFS-VISIT(G, u, time)
    time = time + 1
    u.d = time
    u.color = GRAY
    for each vertex v in G.Adj(u)
        if v.color == WHITE
            v.$\pi$ = u
            DFS-VISIT(G, v, time)
    u.color = BLACK
    time = time + 1
    u.f = time

DFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    DFS(G)
    for each u in G.V
        print str(u) + " f=" + str(u.f)

BUBBLESORT(A, n)
    for i = 1 to n - 1
        for j = n downto i + 1
            if A[j] < A[j - 1]
                exchange A[j] with A[j - 1]

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

A = [5, 4, 3, 2, 1]
print A
INSERTION-SORT(A, 5)
print A

MERGE(A, p, q, r)
    // this is a comment
    n$_L$ = q - p + 1
    n$_R$ = r - q
    let L[0:n$_L$ - 1] and R[0:n$_R$ - 1] be new arrays
    for i = 0 to n$_L$ - 1
        L[i] = A[p + i]
    for j = 0 to n$_R$ - 1
        R[j] = A[q + j + 1]
    i = 0
    j = 0
    k = p
    while i < n$_L$ and j < n$_R$
        if L[i] <= R[j]
            A[k] = L[i]
            i = i + 1
        else A[k] = R[j]
            j = j + 1
        k = k + 1
    while i < n$_L$
        A[k] = L[i]
        i = i + 1
        k = k + 1
    while j < n$_R$
        A[k] = R[j]
        j = j + 1
        k = k + 1

let A[1:10] be a new array
for i = 1 to 5
    A[i] = i + 10
    A[i + 5] = i + 10

print A
MERGE(A, 1, 5, 10)
print A

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

let A$_l$[1:5] be a new array
for i = 1 to 5
    A$_l$[i] = 6 - i
print A$_l$
INSERTION-SORT(A$_l$, 5)
print A$_l$

MATRIX-MULTIPLY(A, B, C, n)
    for i = 1 to n
        for j = 1 to n
            for k = 1 to n
                C[i][j] = C[i][j] + A[i][k] * B[k][j]

ONLINE-MAXIMUM(k, n)
    best-score = -infinity
    for i = 1 to k
        if score(i) > best-score
            best-score = score(i)
    for i = k + 1 to n
        if score(i) > best-score
            return i
    return n

PERMUTE-BY-CYCLE(A, n)
    let B[1:n] be a new array
    offset = RANDOM(1, n)
    for i = 1 to n
        dest = i + offset
        if dest > n
            dest = dest - n
        B[dest] = A[i]
    return B

let A[1:20] be a new array
for i = 1 to 20
    A[i] = 10 * i + RANDOM(0, 9)
print A
B = PERMUTE-BY-CYCLE(A, 20)
print B

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.1
PARENT(i)
    // could alternatively use i \\ 2
    return floor(i / 2)

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MIN-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] < A[i]
        smallest = l
    else
        smallest = i
    if r <= A.heap-size and A[r] < A[smallest]
        smallest = r
    if smallest != i
        exchange A[i] with A[smallest]
        MIN-HEAPIFY(A, smallest)

MIN-HEAP-MINIMUM(A)
    if A.heap-size < 1
        error "heap underflow"
    return A[1]

BUILD-MIN-HEAP(A, n)
    A.heap-size = n
    for i = PARENT(n) downto 1
        MIN-HEAPIFY(A, i)

EXTRACT-MIN(A)
    min = A[1]
    A[1] = A[A.heap-size]
    A.heap-size = A.heap-size - 1
    MIN-HEAPIFY(A, 1)
    return min

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MAX-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] > A[i]
        largest = l
    else largest = i
    if r <= A.heap-size and A[r] > A[largest]
        largest = r
    if largest != i
        exchange A[i] with A[largest]
        MAX-HEAPIFY(A, largest)

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.4
HEAPSORT(A, n)
    BUILD-MAX-HEAP(A, n)
    for i = n downto 2
        exchange A[1] with A[i]
        A.heap-size = A.heap-size - 1
        MAX-HEAPIFY(A, 1)

PARTITION(A, p, r)
    x = A[r]
    i = p - 1
    for j = p to r - 1
        if A[j] <= x
            i = i + 1
            exchange A[i] with A[j]
    exchange A[i + 1] with A[r]
    return i + 1

QUICKSORT(A, p, r)
    if p < r
        q = PARTITION(A, p, r)
        QUICKSORT(A, p, q - 1)
        QUICKSORT(A, q + 1, r)

COUNTING-SORT(A, n, k)
    let B[1:n] and C[0:k] be new arrays
    for i = 0 to k
        C[i] = 0
    for j = 1 to n
        C[A[j]] = C[A[j]] + 1
    // C[i] now contains the number of elements equal to i
    for i = 1 to k
        C[i] = C[i] + C[i - 1]
    // C[i] now contains the number of elements less than or equal to i
    // Copy A to B, starting from the enf od A
    for j = n downto 1
        B[C[A[j]]] = A[j]
        C[A[j]] = C[A[j]] - 1 // to handle duplicate values
    return B

LIST-INSERT(x, y)
    x.next = y.next
    x.prev = y
    if y.next != NIL
        y.next.prev = x
    y.next = x

LIST-INSERT'(x, y)
    x.next = y.next
    x.prev = y
    y.next.prev = x
    y.next = x

LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-SEARCH'(L, k)
    L.nil.key = k
    x = L.nil.next
    while x.key != k
        x = x.next
    if x == L.nil
        return NIL
    else return x

ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

STACK-EMPTY(S)
    if S.top == 0
        return TRUE
    else return FALSE

PUSH(S, x)
    if S.top == S.size
        error "overflow"
    else
        S.top = S.top + 1
        S[S.top] = x

POP(S)
    if STACK-EMPTY(S)
        error "underflow"
    else
        S.top = S.top - 1
        return S[S.top + 1]

// section 11.2

// linked list algorithms
LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-DELETE(L, x)
    if x.prev != NIL
        x.prev.next = x.next
    else L.head = x.next
    if x.next != NIL
        x.next.prev = x.prev

// dummy hash function impl.
h(x)
    return x

CHAINED-HASH-INSERT(T, k, x)
    let N[NIL,NIL,k,x] be a new listnode
    LIST-PREPEND(T[h(N.key)], N)

CHAINED-HASH-SEARCH(T, k)
    found = LIST-SEARCH(T[h(k)], k)
    if found != NIL
        return found.value
    else return NIL

CHAINED-HASH-DELETE(T, k)
    subject = LIST-SEARCH(T[h(k)], k)
    LIST-DELETE(T[h(k)], subject)

INORDER-TREE-WALK(x)
    if x != NIL
        INORDER-TREE-WALK(x.left)
        print x.key
        INORDER-TREE-WALK(x.right)

TREE-SEARCH(x, k)
    if x == NIL or k == x.key
        return x
    if k < x.key
        return TREE-SEARCH(x.left, k)
    else return TREE-SEARCH(x.right, k)

ITERATIVE-TREE-SEARCH(x, k)
    while x != NIL and k != x.key
        if k < x.key
            x = x.left
        else x = x.right
    return x

TREE-MINIMUM(x)
    while x.left != NIL
        x = x.left
    return x

TREE-MAXIMUM(x)
    while x.right != NIL
        x = x.right
    return x

TREE-INSERT(T, z)
    x = T.root
    y = NIL
    while x != NIL
        y = x
        if z.key < x.key
            x = x.left
        else x = x.right
    z.p = y
    if y == NIL
        T.root = z
    else if z.key < y.key
        y.left = z
    else y.right = z

TRANSPLANT(T, u, v)
    if u.p == NIL
        T.root = v
    else if u == u.p.left
        u.p.left = v
    else u.p.right = v
    if v != NIL
        v.p = u.p

TREE-DELETE(T, z)
    if z.left == NIL
        TRANSPLANT(T, z, z.right)
    else if z.right == NIL
        TRANSPLANT(T, z, z.left)
    else y = TREE-MINIMUM(z.right)
        if y != z.right
            TRANSPLANT(T, y, y.right)
            y.right = z.right
            y.right.p = y
        TRANSPLANT(T, z, y);
        y.left = z.left
        y.left.p = y

CUT-ROD(p, n)
    if n == 0
        return 0
    q = -$\infty$
    for i = 1 to n
        q = max(q, p[i] + CUT-ROD(p, n - i))
    return q

MEMOIZED-CUT-ROD(p, n)
    let r[0:n] be a new array
    for i = 0 to n
        r[i] = -$\infty$
    return MEMOIZED-CUT-ROD-AUX(p, n, r)

MEMOIZED-CUT-ROD-AUX(p, n, r)
    if r[n] >= 0
        return r[n]
    if n == 0
        q = 0
    else q = -$\infty$
        for i = 1 to n
            q = max(q, p[i] + MEMOIZED-CUT-ROD(p, n - i, r))
    r[n] = q
    return q

BOTTOM-UP-CUT-ROD(p, n)
    let r[0:n] be a new array
    r[0] = 0
    for j = 1 to n
        q = -$\infty$
        for i = 1 to j
            q = max(q, p[i] + r[j - i])
        r[j] = q
    return r[n]

let prices[1:10] be a new array
prices[1] = 1
prices[2] = 5
prices[3] = 8
prices[4] = 9
prices[5] = 12
prices[6] = 17
prices[7] = 17
prices[8] = 20
prices[9] = 24
prices[10] = 30
n = 4
max-price = CUT-ROD(prices, n)
print max-price

// Priority Queues
LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

PARENT(i)
    return i / 2

INSERT(Q, u)
    Q.heap-size = Q.heap-size + 1
    Q[Q.heap-size] = u
    DECREASE-KEY(Q, u, u.d)

MIN-HEAPIFY(Q, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= Q.heap-size and Q[l].d < Q[i].d
        smallest = l
    else
        smallest = i
    if r <= Q.heap-size and Q[r].d < Q[smallest].d
        smallest = r
    if smallest != i
        exchange Q[i] with Q[smallest]
        MIN-HEAPIFY(Q, smallest)

EXTRACT-MIN(Q)
    min = Q[1]
    Q[1] = Q[Q.heap-size]
    Q.heap-size = Q.heap-size - 1
    MIN-HEAPIFY(Q, 1)
    return min

DECREASE-KEY(Q, v, k)
    for i = 1 to Q.heap-size
        // key will have already been adjusted by RELAX
        if Q[i].key == v.key
            Q[i].d = k
            exchange Q[i] with Q[1]
            MIN-HEAPIFY(Q, 1)

INITIALIZE-SINGLE-SOURCE(G, s)
    for each vertex v in G.V
        v.d = $\infty$
        v.$\pi$ = NIL
    s.d = 0

RELAX(u, v, w)
    if v.d > u.d + w(u, v)
        v.d = u.d + w(u, v)
        v.$\pi$ = u
        return TRUE
    return FALSE

SET-UNION(s, v)
    return s + v

DIJKSTRA(G, w, s)
    INITIALIZE-SINGLE-SOURCE(G, s);
    let S be a new set
    let Q[len(G.V)] be a new priorityqueue
    for each vertex v in G.V
        INSERT(Q, v)
    while Q
        u = EXTRACT-MIN(Q)
        S = S | {u}
        for each vertex v in G.Adj(u)
            did-decrease = RELAX(u, v, w)
            if did-decrease
                DECREASE-KEY(Q, v, v.d)


DIJKSTRA-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 10
    adj-mat[1][4] = 5
    adj-mat[2][3] = 1
    adj-mat[2][4] = 2
    adj-mat[3][5] = 4
    adj-mat[4][2] = 3
    adj-mat[4][3] = 9
    adj-mat[4][5] = 2
    adj-mat[5][3] = 6

    w(u, v)
        return adj-mat[u.key][v.key]

    let G[adj-mat] be a new graph
    DIJKSTRA(G, w, G.V[1])
    print "done"

    for each u in G.V
        print u

DIJKSTRA-EXAMPLE()

// Queue operations
ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

BFS(G, s)
    // for each vertex u in G.V - {s}
    for each vertex u in G.V
        if u == s
            continue
        u.color = WHITE
        u.d = $\infty$
        u.$\pi$ = NIL
    s.color = GRAY
    s.d = 0
    s.$\pi$ = NIL
    let Q[len(G.V) + 1] be a new queue
    ENQUEUE(Q, s)
    while len(Q) > 0
        u = DEQUEUE(Q)
        for each vertex v in G.Adj(u)
            if v.color == WHITE
                v.color = GRAY
                v.d = u.d + 1
                v.$\pi$ = u
                ENQUEUE(Q, v)
        u.color = BLACK

BFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    BFS(G, G.V[1])
    for each u in G.V
        print u

DFS(G)
    for each vertex u in G.V
        u.color = WHITE
        u.$\pi$ = NIL
    time = 0
    for each vertex u in G.V
        if u.color == WHITE
            DFS-VISIT(G, u, time)

DFS-VISIT(G, u, time)
    time = time + 1
    u.d = time
    u.color = GRAY
    for each vertex v in G.Adj(u)
        if v.color == WHITE
            v.$\pi$ = u
            DFS-VISIT(G, v, time)
    u.color = BLACK
    time = time + 1
    u.f = time

DFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    DFS(G)
    for each u in G.V
        print str(u) + " f=" + str(u.f)

BUBBLESORT(A, n)
    for i = 1 to n - 1
        for j = n downto i + 1
            if A[j] < A[j - 1]
                exchange A[j] with A[j - 1]

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

A = [5, 4, 3, 2, 1]
print A
INSERTION-SORT(A, 5)
print A

MERGE(A, p, q, r)
    // this is a comment
    n$_L$ = q - p + 1
    n$_R$ = r - q
    let L[0:n$_L$ - 1] and R[0:n$_R$ - 1] be new arrays
    for i = 0 to n$_L$ - 1
        L[i] = A[p + i]
    for j = 0 to n$_R$ - 1
        R[j] = A[q + j + 1]
    i = 0
    j = 0
    k = p
    while i < n$_L$ and j < n$_R$
        if L[i] <= R[j]
            A[k] = L[i]
            i = i + 1
        else A[k] = R[j]
            j = j + 1
        k = k + 1
    while i < n$_L$
        A[k] = L[i]
        i = i + 1
        k = k + 1
    while j < n$_R$
        A[k] = R[j]
        j = j + 1
        k = k + 1

let A[1:10] be a new array
for i = 1 to 5
    A[i] = i + 10
    A[i + 5] = i + 10

print A
MERGE(A, 1, 5, 10)
print A

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

let A$_l$[1:5] be a new array
for i = 1 to 5
    A$_l$[i] = 6 - i
print A$_l$
INSERTION-SORT(A$_l$, 5)
print A$_l$

MATRIX-MULTIPLY(A, B, C, n)
    for i = 1 to n
        for j = 1 to n
            for k = 1 to n
                C[i][j] = C[i][j] + A[i][k] * B[k][j]

ONLINE-MAXIMUM(k, n)
    best-score = -infinity
    for i = 1 to k
        if score(i) > best-score
            best-score = score(i)
    for i = k + 1 to n
        if score(i) > best-score
            return i
    return n

PERMUTE-BY-CYCLE(A, n)
    let B[1:n] be a new array
    offset = RANDOM(1, n)
    for i = 1 to n
        dest = i + offset
        if dest > n
            dest = dest - n
        B[dest] = A[i]
    return B

let A[1:20] be a new array
for i = 1 to 20
    A[i] = 10 * i + RANDOM(0, 9)
print A
B = PERMUTE-BY-CYCLE(A, 20)
print B

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.1
PARENT(i)
    // could alternatively use i \\ 2
    return floor(i / 2)

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MIN-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] < A[i]
        smallest = l
    else
        smallest = i
    if r <= A.heap-size and A[r] < A[smallest]
        smallest = r
    if smallest != i
        exchange A[i] with A[smallest]
        MIN-HEAPIFY(A, smallest)

MIN-HEAP-MINIMUM(A)
    if A.heap-size < 1
        error "heap underflow"
    return A[1]

BUILD-MIN-HEAP(A, n)
    A.heap-size = n
    for i = PARENT(n) downto 1
        MIN-HEAPIFY(A, i)

EXTRACT-MIN(A)
    min = A[1]
    A[1] = A[A.heap-size]
    A.heap-size = A.heap-size - 1
    MIN-HEAPIFY(A, 1)
    return min

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MAX-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] > A[i]
        largest = l
    else largest = i
    if r <= A.heap-size and A[r] > A[largest]
        largest = r
    if largest != i
        exchange A[i] with A[largest]
        MAX-HEAPIFY(A, largest)

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.4
HEAPSORT(A, n)
    BUILD-MAX-HEAP(A, n)
    for i = n downto 2
        exchange A[1] with A[i]
        A.heap-size = A.heap-size - 1
        MAX-HEAPIFY(A, 1)

PARTITION(A, p, r)
    x = A[r]
    i = p - 1
    for j = p to r - 1
        if A[j] <= x
            i = i + 1
            exchange A[i] with A[j]
    exchange A[i + 1] with A[r]
    return i + 1

QUICKSORT(A, p, r)
    if p < r
        q = PARTITION(A, p, r)
        QUICKSORT(A, p, q - 1)
        QUICKSORT(A, q + 1, r)

COUNTING-SORT(A, n, k)
    let B[1:n] and C[0:k] be new arrays
    for i = 0 to k
        C[i] = 0
    for j = 1 to n
        C[A[j]] = C[A[j]] + 1
    // C[i] now contains the number of elements equal to i
    for i = 1 to k
        C[i] = C[i] + C[i - 1]
    // C[i] now contains the number of elements less than or equal to i
    // Copy A to B, starting from the enf od A
    for j = n downto 1
        B[C[A[j]]] = A[j]
        C[A[j]] = C[A[j]] - 1 // to handle duplicate values
    return B

LIST-INSERT(x, y)
    x.next = y.next
    x.prev = y
    if y.next != NIL
        y.next.prev = x
    y.next = x

LIST-INSERT'(x, y)
    x.next = y.next
    x.prev = y
    y.next.prev = x
    y.next = x

LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-SEARCH'(L, k)
    L.nil.key = k
    x = L.nil.next
    while x.key != k
        x = x.next
    if x == L.nil
        return NIL
    else return x

ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

STACK-EMPTY(S)
    if S.top == 0
        return TRUE
    else return FALSE

PUSH(S, x)
    if S.top == S.size
        error "overflow"
    else
        S.top = S.top + 1
        S[S.top] = x

POP(S)
    if STACK-EMPTY(S)
        error "underflow"
    else
        S.top = S.top - 1
        return S[S.top + 1]

// section 11.2

// linked list algorithms
LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-DELETE(L, x)
    if x.prev != NIL
        x.prev.next = x.next
    else L.head = x.next
    if x.next != NIL
        x.next.prev = x.prev

// dummy hash function impl.
h(x)
    return x

CHAINED-HASH-INSERT(T, k, x)
    let N[NIL,NIL,k,x] be a new listnode
    LIST-PREPEND(T[h(N.key)], N)

CHAINED-HASH-SEARCH(T, k)
    found = LIST-SEARCH(T[h(k)], k)
    if found != NIL
        return found.value
    else return NIL

CHAINED-HASH-DELETE(T, k)
    subject = LIST-SEARCH(T[h(k)], k)
    LIST-DELETE(T[h(k)], subject)

INORDER-TREE-WALK(x)
    if x != NIL
        INORDER-TREE-WALK(x.left)
        print x.key
        INORDER-TREE-WALK(x.right)

TREE-SEARCH(x, k)
    if x == NIL or k == x.key
        return x
    if k < x.key
        return TREE-SEARCH(x.left, k)
    else return TREE-SEARCH(x.right, k)

ITERATIVE-TREE-SEARCH(x, k)
    while x != NIL and k != x.key
        if k < x.key
            x = x.left
        else x = x.right
    return x

TREE-MINIMUM(x)
    while x.left != NIL
        x = x.left
    return x

TREE-MAXIMUM(x)
    while x.right != NIL
        x = x.right
    return x

TREE-INSERT(T, z)
    x = T.root
    y = NIL
    while x != NIL
        y = x
        if z.key < x.key
            x = x.left
        else x = x.right
    z.p = y
    if y == NIL
        T.root = z
    else if z.key < y.key
        y.left = z
    else y.right = z

TRANSPLANT(T, u, v)
    if u.p == NIL
        T.root = v
    else if u == u.p.left
        u.p.left = v
    else u.p.right = v
    if v != NIL
        v.p = u.p

TREE-DELETE(T, z)
    if z.left == NIL
        TRANSPLANT(T, z, z.right)
    else if z.right == NIL
        TRANSPLANT(T, z, z.left)
    else y = TREE-MINIMUM(z.right)
        if y != z.right
            TRANSPLANT(T, y, y.right)
            y.right = z.right
            y.right.p = y
        TRANSPLANT(T, z, y);
        y.left = z.left
        y.left.p = y

CUT-ROD(p, n)
    if n == 0
        return 0
    q = -$\infty$
    for i = 1 to n
        q = max(q, p[i] + CUT-ROD(p, n - i))
    return q

MEMOIZED-CUT-ROD(p, n)
    let r[0:n] be a new array
    for i = 0 to n
        r[i] = -$\infty$
    return MEMOIZED-CUT-ROD-AUX(p, n, r)

MEMOIZED-CUT-ROD-AUX(p, n, r)
    if r[n] >= 0
        return r[n]
    if n == 0
        q = 0
    else q = -$\infty$
        for i = 1 to n
            q = max(q, p[i] + MEMOIZED-CUT-ROD(p, n - i, r))
    r[n] = q
    return q

BOTTOM-UP-CUT-ROD(p, n)
    let r[0:n] be a new array
    r[0] = 0
    for j = 1 to n
        q = -$\infty$
        for i = 1 to j
            q = max(q, p[i] + r[j - i])
        r[j] = q
    return r[n]

let prices[1:10] be a new array
prices[1] = 1
prices[2] = 5
prices[3] = 8
prices[4] = 9
prices[5] = 12
prices[6] = 17
prices[7] = 17
prices[8] = 20
prices[9] = 24
prices[10] = 30
n = 4
max-price = CUT-ROD(prices, n)
print max-price

// Priority Queues
LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

PARENT(i)
    return i / 2

INSERT(Q, u)
    Q.heap-size = Q.heap-size + 1
    Q[Q.heap-size] = u
    DECREASE-KEY(Q, u, u.d)

MIN-HEAPIFY(Q, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= Q.heap-size and Q[l].d < Q[i].d
        smallest = l
    else
        smallest = i
    if r <= Q.heap-size and Q[r].d < Q[smallest].d
        smallest = r
    if smallest != i
        exchange Q[i] with Q[smallest]
        MIN-HEAPIFY(Q, smallest)

EXTRACT-MIN(Q)
    min = Q[1]
    Q[1] = Q[Q.heap-size]
    Q.heap-size = Q.heap-size - 1
    MIN-HEAPIFY(Q, 1)
    return min

DECREASE-KEY(Q, v, k)
    for i = 1 to Q.heap-size
        // key will have already been adjusted by RELAX
        if Q[i].key == v.key
            Q[i].d = k
            exchange Q[i] with Q[1]
            MIN-HEAPIFY(Q, 1)

INITIALIZE-SINGLE-SOURCE(G, s)
    for each vertex v in G.V
        v.d = $\infty$
        v.$\pi$ = NIL
    s.d = 0

RELAX(u, v, w)
    if v.d > u.d + w(u, v)
        v.d = u.d + w(u, v)
        v.$\pi$ = u
        return TRUE
    return FALSE

SET-UNION(s, v)
    return s + v

DIJKSTRA(G, w, s)
    INITIALIZE-SINGLE-SOURCE(G, s);
    let S be a new set
    let Q[len(G.V)] be a new priorityqueue
    for each vertex v in G.V
        INSERT(Q, v)
    while Q
        u = EXTRACT-MIN(Q)
        S = S | {u}
        for each vertex v in G.Adj(u)
            did-decrease = RELAX(u, v, w)
            if did-decrease
                DECREASE-KEY(Q, v, v.d)


DIJKSTRA-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 10
    adj-mat[1][4] = 5
    adj-mat[2][3] = 1
    adj-mat[2][4] = 2
    adj-mat[3][5] = 4
    adj-mat[4][2] = 3
    adj-mat[4][3] = 9
    adj-mat[4][5] = 2
    adj-mat[5][3] = 6

    w(u, v)
        return adj-mat[u.key][v.key]

    let G[adj-mat] be a new graph
    DIJKSTRA(G, w, G.V[1])
    print "done"

    for each u in G.V
        print u

DIJKSTRA-EXAMPLE()

// Queue operations
ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

BFS(G, s)
    // for each vertex u in G.V - {s}
    for each vertex u in G.V
        if u == s
            continue
        u.color = WHITE
        u.d = $\infty$
        u.$\pi$ = NIL
    s.color = GRAY
    s.d = 0
    s.$\pi$ = NIL
    let Q[len(G.V) + 1] be a new queue
    ENQUEUE(Q, s)
    while len(Q) > 0
        u = DEQUEUE(Q)
        for each vertex v in G.Adj(u)
            if v.color == WHITE
                v.color = GRAY
                v.d = u.d + 1
                v.$\pi$ = u
                ENQUEUE(Q, v)
        u.color = BLACK

BFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    BFS(G, G.V[1])
    for each u in G.V
        print u

DFS(G)
    for each vertex u in G.V
        u.color = WHITE
        u.$\pi$ = NIL
    time = 0
    for each vertex u in G.V
        if u.color == WHITE
            DFS-VISIT(G, u, time)

DFS-VISIT(G, u, time)
    time = time + 1
    u.d = time
    u.color = GRAY
    for each vertex v in G.Adj(u)
        if v.color == WHITE
            v.$\pi$ = u
            DFS-VISIT(G, v, time)
    u.color = BLACK
    time = time + 1
    u.f = time

DFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    DFS(G)
    for each u in G.V
        print str(u) + " f=" + str(u.f)

BUBBLESORT(A, n)
    for i = 1 to n - 1
        for j = n downto i + 1
            if A[j] < A[j - 1]
                exchange A[j] with A[j - 1]

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

A = [5, 4, 3, 2, 1]
print A
INSERTION-SORT(A, 5)
print A

MERGE(A, p, q, r)
    // this is a comment
    n$_L$ = q - p + 1
    n$_R$ = r - q
    let L[0:n$_L$ - 1] and R[0:n$_R$ - 1] be new arrays
    for i = 0 to n$_L$ - 1
        L[i] = A[p + i]
    for j = 0 to n$_R$ - 1
        R[j] = A[q + j + 1]
    i = 0
    j = 0
    k = p
    while i < n$_L$ and j < n$_R$
        if L[i] <= R[j]
            A[k] = L[i]
            i = i + 1
        else A[k] = R[j]
            j = j + 1
        k = k + 1
    while i < n$_L$
        A[k] = L[i]
        i = i + 1
        k = k + 1
    while j < n$_R$
        A[k] = R[j]
        j = j + 1
        k = k + 1

let A[1:10] be a new array
for i = 1 to 5
    A[i] = i + 10
    A[i + 5] = i + 10

print A
MERGE(A, 1, 5, 10)
print A

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

let A$_l$[1:5] be a new array
for i = 1 to 5
    A$_l$[i] = 6 - i
print A$_l$
INSERTION-SORT(A$_l$, 5)
print A$_l$

MATRIX-MULTIPLY(A, B, C, n)
    for i = 1 to n
        for j = 1 to n
            for k = 1 to n
                C[i][j] = C[i][j] + A[i][k] * B[k][j]

ONLINE-MAXIMUM(k, n)
    best-score = -infinity
    for i = 1 to k
        if score(i) > best-score
            best-score = score(i)
    for i = k + 1 to n
        if score(i) > best-score
            return i
    return n

PERMUTE-BY-CYCLE(A, n)
    let B[1:n] be a new array
    offset = RANDOM(1, n)
    for i = 1 to n
        dest = i + offset
        if dest > n
            dest = dest - n
        B[dest] = A[i]
    return B

let A[1:20] be a new array
for i = 1 to 20
    A[i] = 10 * i + RANDOM(0, 9)
print A
B = PERMUTE-BY-CYCLE(A, 20)
print B

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.1
PARENT(i)
    // could alternatively use i \\ 2
    return floor(i / 2)

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MIN-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] < A[i]
        smallest = l
    else
        smallest = i
    if r <= A.heap-size and A[r] < A[smallest]
        smallest = r
    if smallest != i
        exchange A[i] with A[smallest]
        MIN-HEAPIFY(A, smallest)

MIN-HEAP-MINIMUM(A)
    if A.heap-size < 1
        error "heap underflow"
    return A[1]

BUILD-MIN-HEAP(A, n)
    A.heap-size = n
    for i = PARENT(n) downto 1
        MIN-HEAPIFY(A, i)

EXTRACT-MIN(A)
    min = A[1]
    A[1] = A[A.heap-size]
    A.heap-size = A.heap-size - 1
    MIN-HEAPIFY(A, 1)
    return min

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MAX-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] > A[i]
        largest = l
    else largest = i
    if r <= A.heap-size and A[r] > A[largest]
        largest = r
    if largest != i
        exchange A[i] with A[largest]
        MAX-HEAPIFY(A, largest)

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.4
HEAPSORT(A, n)
    BUILD-MAX-HEAP(A, n)
    for i = n downto 2
        exchange A[1] with A[i]
        A.heap-size = A.heap-size - 1
        MAX-HEAPIFY(A, 1)

PARTITION(A, p, r)
    x = A[r]
    i = p - 1
    for j = p to r - 1
        if A[j] <= x
            i = i + 1
            exchange A[i] with A[j]
    exchange A[i + 1] with A[r]
    return i + 1

QUICKSORT(A, p, r)
    if p < r
        q = PARTITION(A, p, r)
        QUICKSORT(A, p, q - 1)
        QUICKSORT(A, q + 1, r)

COUNTING-SORT(A, n, k)
    let B[1:n] and C[0:k] be new arrays
    for i = 0 to k
        C[i] = 0
    for j = 1 to n
        C[A[j]] = C[A[j]] + 1
    // C[i] now contains the number of elements equal to i
    for i = 1 to k
        C[i] = C[i] + C[i - 1]
    // C[i] now contains the number of elements less than or equal to i
    // Copy A to B, starting from the enf od A
    for j = n downto 1
        B[C[A[j]]] = A[j]
        C[A[j]] = C[A[j]] - 1 // to handle duplicate values
    return B

LIST-INSERT(x, y)
    x.next = y.next
    x.prev = y
    if y.next != NIL
        y.next.prev = x
    y.next = x

LIST-INSERT'(x, y)
    x.next = y.next
    x.prev = y
    y.next.prev = x
    y.next = x

LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-SEARCH'(L, k)
    L.nil.key = k
    x = L.nil.next
    while x.key != k
        x = x.next
    if x == L.nil
        return NIL
    else return x

ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

STACK-EMPTY(S)
    if S.top == 0
        return TRUE
    else return FALSE

PUSH(S, x)
    if S.top == S.size
        error "overflow"
    else
        S.top = S.top + 1
        S[S.top] = x

POP(S)
    if STACK-EMPTY(S)
        error "underflow"
    else
        S.top = S.top - 1
        return S[S.top + 1]

// section 11.2

// linked list algorithms
LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-DELETE(L, x)
    if x.prev != NIL
        x.prev.next = x.next
    else L.head = x.next
    if x.next != NIL
        x.next.prev = x.prev

// dummy hash function impl.
h(x)
    return x

CHAINED-HASH-INSERT(T, k, x)
    let N[NIL,NIL,k,x] be a new listnode
    LIST-PREPEND(T[h(N.key)], N)

CHAINED-HASH-SEARCH(T, k)
    found = LIST-SEARCH(T[h(k)], k)
    if found != NIL
        return found.value
    else return NIL

CHAINED-HASH-DELETE(T, k)
    subject = LIST-SEARCH(T[h(k)], k)
    LIST-DELETE(T[h(k)], subject)

INORDER-TREE-WALK(x)
    if x != NIL
        INORDER-TREE-WALK(x.left)
        print x.key
        INORDER-TREE-WALK(x.right)

TREE-SEARCH(x, k)
    if x == NIL or k == x.key
        return x
    if k < x.key
        return TREE-SEARCH(x.left, k)
    else return TREE-SEARCH(x.right, k)

ITERATIVE-TREE-SEARCH(x, k)
    while x != NIL and k != x.key
        if k < x.key
            x = x.left
        else x = x.right
    return x

TREE-MINIMUM(x)
    while x.left != NIL
        x = x.left
    return x

TREE-MAXIMUM(x)
    while x.right != NIL
        x = x.right
    return x

TREE-INSERT(T, z)
    x = T.root
    y = NIL
    while x != NIL
        y = x
        if z.key < x.key
            x = x.left
        else x = x.right
    z.p = y
    if y == NIL
        T.root = z
    else if z.key < y.key
        y.left = z
    else y.right = z

TRANSPLANT(T, u, v)
    if u.p == NIL
        T.root = v
    else if u == u.p.left
        u.p.left = v
    else u.p.right = v
    if v != NIL
        v.p = u.p

TREE-DELETE(T, z)
    if z.left == NIL
        TRANSPLANT(T, z, z.right)
    else if z.right == NIL
        TRANSPLANT(T, z, z.left)
    else y = TREE-MINIMUM(z.right)
        if y != z.right
            TRANSPLANT(T, y, y.right)
            y.right = z.right
            y.right.p = y
        TRANSPLANT(T, z, y);
        y.left = z.left
        y.left.p = y

CUT-ROD(p, n)
    if n == 0
        return 0
    q = -$\infty$
    for i = 1 to n
        q = max(q, p[i] + CUT-ROD(p, n - i))
    return q

MEMOIZED-CUT-ROD(p, n)
    let r[0:n] be a new array
    for i = 0 to n
        r[i] = -$\infty$
    return MEMOIZED-CUT-ROD-AUX(p, n, r)

MEMOIZED-CUT-ROD-AUX(p, n, r)
    if r[n] >= 0
        return r[n]
    if n == 0
        q = 0
    else q = -$\infty$
        for i = 1 to n
            q = max(q, p[i] + MEMOIZED-CUT-ROD(p, n - i, r))
    r[n] = q
    return q

BOTTOM-UP-CUT-ROD(p, n)
    let r[0:n] be a new array
    r[0] = 0
    for j = 1 to n
        q = -$\infty$
        for i = 1 to j
            q = max(q, p[i] + r[j - i])
        r[j] = q
    return r[n]

let prices[1:10] be a new array
prices[1] = 1
prices[2] = 5
prices[3] = 8
prices[4] = 9
prices[5] = 12
prices[6] = 17
prices[7] = 17
prices[8] = 20
prices[9] = 24
prices[10] = 30
n = 4
max-price = CUT-ROD(prices, n)
print max-price

// Priority Queues
LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

PARENT(i)
    return i / 2

INSERT(Q, u)
    Q.heap-size = Q.heap-size + 1
    Q[Q.heap-size] = u
    DECREASE-KEY(Q, u, u.d)

MIN-HEAPIFY(Q, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= Q.heap-size and Q[l].d < Q[i].d
        smallest = l
    else
        smallest = i
    if r <= Q.heap-size and Q[r].d < Q[smallest].d
        smallest = r
    if smallest != i
        exchange Q[i] with Q[smallest]
        MIN-HEAPIFY(Q, smallest)

EXTRACT-MIN(Q)
    min = Q[1]
    Q[1] = Q[Q.heap-size]
    Q.heap-size = Q.heap-size - 1
    MIN-HEAPIFY(Q, 1)
    return min

DECREASE-KEY(Q, v, k)
    for i = 1 to Q.heap-size
        // key will have already been adjusted by RELAX
        if Q[i].key == v.key
            Q[i].d = k
            exchange Q[i] with Q[1]
            MIN-HEAPIFY(Q, 1)

INITIALIZE-SINGLE-SOURCE(G, s)
    for each vertex v in G.V
        v.d = $\infty$
        v.$\pi$ = NIL
    s.d = 0

RELAX(u, v, w)
    if v.d > u.d + w(u, v)
        v.d = u.d + w(u, v)
        v.$\pi$ = u
        return TRUE
    return FALSE

SET-UNION(s, v)
    return s + v

DIJKSTRA(G, w, s)
    INITIALIZE-SINGLE-SOURCE(G, s);
    let S be a new set
    let Q[len(G.V)] be a new priorityqueue
    for each vertex v in G.V
        INSERT(Q, v)
    while Q
        u = EXTRACT-MIN(Q)
        S = S | {u}
        for each vertex v in G.Adj(u)
            did-decrease = RELAX(u, v, w)
            if did-decrease
                DECREASE-KEY(Q, v, v.d)


DIJKSTRA-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 10
    adj-mat[1][4] = 5
    adj-mat[2][3] = 1
    adj-mat[2][4] = 2
    adj-mat[3][5] = 4
    adj-mat[4][2] = 3
    adj-mat[4][3] = 9
    adj-mat[4][5] = 2
    adj-mat[5][3] = 6

    w(u, v)
        return adj-mat[u.key][v.key]

    let G[adj-mat] be a new graph
    DIJKSTRA(G, w, G.V[1])
    print "done"

    for each u in G.V
        print u

DIJKSTRA-EXAMPLE()

// Queue operations
ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

BFS(G, s)
    // for each vertex u in G.V - {s}
    for each vertex u in G.V
        if u == s
            continue
        u.color = WHITE
        u.d = $\infty$
        u.$\pi$ = NIL
    s.color = GRAY
    s.d = 0
    s.$\pi$ = NIL
    let Q[len(G.V) + 1] be a new queue
    ENQUEUE(Q, s)
    while len(Q) > 0
        u = DEQUEUE(Q)
        for each vertex v in G.Adj(u)
            if v.color == WHITE
                v.color = GRAY
                v.d = u.d + 1
                v.$\pi$ = u
                ENQUEUE(Q, v)
        u.color = BLACK

BFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    BFS(G, G.V[1])
    for each u in G.V
        print u

DFS(G)
    for each vertex u in G.V
        u.color = WHITE
        u.$\pi$ = NIL
    time = 0
    for each vertex u in G.V
        if u.color == WHITE
            DFS-VISIT(G, u, time)

DFS-VISIT(G, u, time)
    time = time + 1
    u.d = time
    u.color = GRAY
    for each vertex v in G.Adj(u)
        if v.color == WHITE
            v.$\pi$ = u
            DFS-VISIT(G, v, time)
    u.color = BLACK
    time = time + 1
    u.f = time

DFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    DFS(G)
    for each u in G.V
        print str(u) + " f=" + str(u.f)

BUBBLESORT(A, n)
    for i = 1 to n - 1
        for j = n downto i + 1
            if A[j] < A[j - 1]
                exchange A[j] with A[j - 1]

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

A = [5, 4, 3, 2, 1]
print A
INSERTION-SORT(A, 5)
print A

MERGE(A, p, q, r)
    // this is a comment
    n$_L$ = q - p + 1
    n$_R$ = r - q
    let L[0:n$_L$ - 1] and R[0:n$_R$ - 1] be new arrays
    for i = 0 to n$_L$ - 1
        L[i] = A[p + i]
    for j = 0 to n$_R$ - 1
        R[j] = A[q + j + 1]
    i = 0
    j = 0
    k = p
    while i < n$_L$ and j < n$_R$
        if L[i] <= R[j]
            A[k] = L[i]
            i = i + 1
        else A[k] = R[j]
            j = j + 1
        k = k + 1
    while i < n$_L$
        A[k] = L[i]
        i = i + 1
        k = k + 1
    while j < n$_R$
        A[k] = R[j]
        j = j + 1
        k = k + 1

let A[1:10] be a new array
for i = 1 to 5
    A[i] = i + 10
    A[i + 5] = i + 10

print A
MERGE(A, 1, 5, 10)
print A

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

let A$_l$[1:5] be a new array
for i = 1 to 5
    A$_l$[i] = 6 - i
print A$_l$
INSERTION-SORT(A$_l$, 5)
print A$_l$

MATRIX-MULTIPLY(A, B, C, n)
    for i = 1 to n
        for j = 1 to n
            for k = 1 to n
                C[i][j] = C[i][j] + A[i][k] * B[k][j]

ONLINE-MAXIMUM(k, n)
    best-score = -infinity
    for i = 1 to k
        if score(i) > best-score
            best-score = score(i)
    for i = k + 1 to n
        if score(i) > best-score
            return i
    return n

PERMUTE-BY-CYCLE(A, n)
    let B[1:n] be a new array
    offset = RANDOM(1, n)
    for i = 1 to n
        dest = i + offset
        if dest > n
            dest = dest - n
        B[dest] = A[i]
    return B

let A[1:20] be a new array
for i = 1 to 20
    A[i] = 10 * i + RANDOM(0, 9)
print A
B = PERMUTE-BY-CYCLE(A, 20)
print B

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.1
PARENT(i)
    // could alternatively use i \\ 2
    return floor(i / 2)

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MIN-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] < A[i]
        smallest = l
    else
        smallest = i
    if r <= A.heap-size and A[r] < A[smallest]
        smallest = r
    if smallest != i
        exchange A[i] with A[smallest]
        MIN-HEAPIFY(A, smallest)

MIN-HEAP-MINIMUM(A)
    if A.heap-size < 1
        error "heap underflow"
    return A[1]

BUILD-MIN-HEAP(A, n)
    A.heap-size = n
    for i = PARENT(n) downto 1
        MIN-HEAPIFY(A, i)

EXTRACT-MIN(A)
    min = A[1]
    A[1] = A[A.heap-size]
    A.heap-size = A.heap-size - 1
    MIN-HEAPIFY(A, 1)
    return min

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MAX-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] > A[i]
        largest = l
    else largest = i
    if r <= A.heap-size and A[r] > A[largest]
        largest = r
    if largest != i
        exchange A[i] with A[largest]
        MAX-HEAPIFY(A, largest)

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.4
HEAPSORT(A, n)
    BUILD-MAX-HEAP(A, n)
    for i = n downto 2
        exchange A[1] with A[i]
        A.heap-size = A.heap-size - 1
        MAX-HEAPIFY(A, 1)

PARTITION(A, p, r)
    x = A[r]
    i = p - 1
    for j = p to r - 1
        if A[j] <= x
            i = i + 1
            exchange A[i] with A[j]
    exchange A[i + 1] with A[r]
    return i + 1

QUICKSORT(A, p, r)
    if p < r
        q = PARTITION(A, p, r)
        QUICKSORT(A, p, q - 1)
        QUICKSORT(A, q + 1, r)

COUNTING-SORT(A, n, k)
    let B[1:n] and C[0:k] be new arrays
    for i = 0 to k
        C[i] = 0
    for j = 1 to n
        C[A[j]] = C[A[j]] + 1
    // C[i] now contains the number of elements equal to i
    for i = 1 to k
        C[i] = C[i] + C[i - 1]
    // C[i] now contains the number of elements less than or equal to i
    // Copy A to B, starting from the enf od A
    for j = n downto 1
        B[C[A[j]]] = A[j]
        C[A[j]] = C[A[j]] - 1 // to handle duplicate values
    return B

LIST-INSERT(x, y)
    x.next = y.next
    x.prev = y
    if y.next != NIL
        y.next.prev = x
    y.next = x

LIST-INSERT'(x, y)
    x.next = y.next
    x.prev = y
    y.next.prev = x
    y.next = x

LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-SEARCH'(L, k)
    L.nil.key = k
    x = L.nil.next
    while x.key != k
        x = x.next
    if x == L.nil
        return NIL
    else return x

ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

STACK-EMPTY(S)
    if S.top == 0
        return TRUE
    else return FALSE

PUSH(S, x)
    if S.top == S.size
        error "overflow"
    else
        S.top = S.top + 1
        S[S.top] = x

POP(S)
    if STACK-EMPTY(S)
        error "underflow"
    else
        S.top = S.top - 1
        return S[S.top + 1]

// section 11.2

// linked list algorithms
LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-DELETE(L, x)
    if x.prev != NIL
        x.prev.next = x.next
    else L.head = x.next
    if x.next != NIL
        x.next.prev = x.prev

// dummy hash function impl.
h(x)
    return x

CHAINED-HASH-INSERT(T, k, x)
    let N[NIL,NIL,k,x] be a new listnode
    LIST-PREPEND(T[h(N.key)], N)

CHAINED-HASH-SEARCH(T, k)
    found = LIST-SEARCH(T[h(k)], k)
    if found != NIL
        return found.value
    else return NIL

CHAINED-HASH-DELETE(T, k)
    subject = LIST-SEARCH(T[h(k)], k)
    LIST-DELETE(T[h(k)], subject)

INORDER-TREE-WALK(x)
    if x != NIL
        INORDER-TREE-WALK(x.left)
        print x.key
        INORDER-TREE-WALK(x.right)

TREE-SEARCH(x, k)
    if x == NIL or k == x.key
        return x
    if k < x.key
        return TREE-SEARCH(x.left, k)
    else return TREE-SEARCH(x.right, k)

ITERATIVE-TREE-SEARCH(x, k)
    while x != NIL and k != x.key
        if k < x.key
            x = x.left
        else x = x.right
    return x

TREE-MINIMUM(x)
    while x.left != NIL
        x = x.left
    return x

TREE-MAXIMUM(x)
    while x.right != NIL
        x = x.right
    return x

TREE-INSERT(T, z)
    x = T.root
    y = NIL
    while x != NIL
        y = x
        if z.key < x.key
            x = x.left
        else x = x.right
    z.p = y
    if y == NIL
        T.root = z
    else if z.key < y.key
        y.left = z
    else y.right = z

TRANSPLANT(T, u, v)
    if u.p == NIL
        T.root = v
    else if u == u.p.left
        u.p.left = v
    else u.p.right = v
    if v != NIL
        v.p = u.p

TREE-DELETE(T, z)
    if z.left == NIL
        TRANSPLANT(T, z, z.right)
    else if z.right == NIL
        TRANSPLANT(T, z, z.left)
    else y = TREE-MINIMUM(z.right)
        if y != z.right
            TRANSPLANT(T, y, y.right)
            y.right = z.right
            y.right.p = y
        TRANSPLANT(T, z, y);
        y.left = z.left
        y.left.p = y

CUT-ROD(p, n)
    if n == 0
        return 0
    q = -$\infty$
    for i = 1 to n
        q = max(q, p[i] + CUT-ROD(p, n - i))
    return q

MEMOIZED-CUT-ROD(p, n)
    let r[0:n] be a new array
    for i = 0 to n
        r[i] = -$\infty$
    return MEMOIZED-CUT-ROD-AUX(p, n, r)

MEMOIZED-CUT-ROD-AUX(p, n, r)
    if r[n] >= 0
        return r[n]
    if n == 0
        q = 0
    else q = -$\infty$
        for i = 1 to n
            q = max(q, p[i] + MEMOIZED-CUT-ROD(p, n - i, r))
    r[n] = q
    return q

BOTTOM-UP-CUT-ROD(p, n)
    let r[0:n] be a new array
    r[0] = 0
    for j = 1 to n
        q = -$\infty$
        for i = 1 to j
            q = max(q, p[i] + r[j - i])
        r[j] = q
    return r[n]

let prices[1:10] be a new array
prices[1] = 1
prices[2] = 5
prices[3] = 8
prices[4] = 9
prices[5] = 12
prices[6] = 17
prices[7] = 17
prices[8] = 20
prices[9] = 24
prices[10] = 30
n = 4
max-price = CUT-ROD(prices, n)
print max-price

// Priority Queues
LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

PARENT(i)
    return i / 2

INSERT(Q, u)
    Q.heap-size = Q.heap-size + 1
    Q[Q.heap-size] = u
    DECREASE-KEY(Q, u, u.d)

MIN-HEAPIFY(Q, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= Q.heap-size and Q[l].d < Q[i].d
        smallest = l
    else
        smallest = i
    if r <= Q.heap-size and Q[r].d < Q[smallest].d
        smallest = r
    if smallest != i
        exchange Q[i] with Q[smallest]
        MIN-HEAPIFY(Q, smallest)

EXTRACT-MIN(Q)
    min = Q[1]
    Q[1] = Q[Q.heap-size]
    Q.heap-size = Q.heap-size - 1
    MIN-HEAPIFY(Q, 1)
    return min

DECREASE-KEY(Q, v, k)
    for i = 1 to Q.heap-size
        // key will have already been adjusted by RELAX
        if Q[i].key == v.key
            Q[i].d = k
            exchange Q[i] with Q[1]
            MIN-HEAPIFY(Q, 1)

INITIALIZE-SINGLE-SOURCE(G, s)
    for each vertex v in G.V
        v.d = $\infty$
        v.$\pi$ = NIL
    s.d = 0

RELAX(u, v, w)
    if v.d > u.d + w(u, v)
        v.d = u.d + w(u, v)
        v.$\pi$ = u
        return TRUE
    return FALSE

SET-UNION(s, v)
    return s + v

DIJKSTRA(G, w, s)
    INITIALIZE-SINGLE-SOURCE(G, s);
    let S be a new set
    let Q[len(G.V)] be a new priorityqueue
    for each vertex v in G.V
        INSERT(Q, v)
    while Q
        u = EXTRACT-MIN(Q)
        S = S | {u}
        for each vertex v in G.Adj(u)
            did-decrease = RELAX(u, v, w)
            if did-decrease
                DECREASE-KEY(Q, v, v.d)


DIJKSTRA-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 10
    adj-mat[1][4] = 5
    adj-mat[2][3] = 1
    adj-mat[2][4] = 2
    adj-mat[3][5] = 4
    adj-mat[4][2] = 3
    adj-mat[4][3] = 9
    adj-mat[4][5] = 2
    adj-mat[5][3] = 6

    w(u, v)
        return adj-mat[u.key][v.key]

    let G[adj-mat] be a new graph
    DIJKSTRA(G, w, G.V[1])
    print "done"

    for each u in G.V
        print u

DIJKSTRA-EXAMPLE()

// Queue operations
ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

BFS(G, s)
    // for each vertex u in G.V - {s}
    for each vertex u in G.V
        if u == s
            continue
        u.color = WHITE
        u.d = $\infty$
        u.$\pi$ = NIL
    s.color = GRAY
    s.d = 0
    s.$\pi$ = NIL
    let Q[len(G.V) + 1] be a new queue
    ENQUEUE(Q, s)
    while len(Q) > 0
        u = DEQUEUE(Q)
        for each vertex v in G.Adj(u)
            if v.color == WHITE
                v.color = GRAY
                v.d = u.d + 1
                v.$\pi$ = u
                ENQUEUE(Q, v)
        u.color = BLACK

BFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    BFS(G, G.V[1])
    for each u in G.V
        print u

DFS(G)
    for each vertex u in G.V
        u.color = WHITE
        u.$\pi$ = NIL
    time = 0
    for each vertex u in G.V
        if u.color == WHITE
            DFS-VISIT(G, u, time)

DFS-VISIT(G, u, time)
    time = time + 1
    u.d = time
    u.color = GRAY
    for each vertex v in G.Adj(u)
        if v.color == WHITE
            v.$\pi$ = u
            DFS-VISIT(G, v, time)
    u.color = BLACK
    time = time + 1
    u.f = time

DFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    DFS(G)
    for each u in G.V
        print str(u) + " f=" + str(u.f)

BUBBLESORT(A, n)
    for i = 1 to n - 1
        for j = n downto i + 1
            if A[j] < A[j - 1]
                exchange A[j] with A[j - 1]

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

A = [5, 4, 3, 2, 1]
print A
INSERTION-SORT(A, 5)
print A

MERGE(A, p, q, r)
    // this is a comment
    n$_L$ = q - p + 1
    n$_R$ = r - q
    let L[0:n$_L$ - 1] and R[0:n$_R$ - 1] be new arrays
    for i = 0 to n$_L$ - 1
        L[i] = A[p + i]
    for j = 0 to n$_R$ - 1
        R[j] = A[q + j + 1]
    i = 0
    j = 0
    k = p
    while i < n$_L$ and j < n$_R$
        if L[i] <= R[j]
            A[k] = L[i]
            i = i + 1
        else A[k] = R[j]
            j = j + 1
        k = k + 1
    while i < n$_L$
        A[k] = L[i]
        i = i + 1
        k = k + 1
    while j < n$_R$
        A[k] = R[j]
        j = j + 1
        k = k + 1

let A[1:10] be a new array
for i = 1 to 5
    A[i] = i + 10
    A[i + 5] = i + 10

print A
MERGE(A, 1, 5, 10)
print A

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

let A$_l$[1:5] be a new array
for i = 1 to 5
    A$_l$[i] = 6 - i
print A$_l$
INSERTION-SORT(A$_l$, 5)
print A$_l$

MATRIX-MULTIPLY(A, B, C, n)
    for i = 1 to n
        for j = 1 to n
            for k = 1 to n
                C[i][j] = C[i][j] + A[i][k] * B[k][j]

ONLINE-MAXIMUM(k, n)
    best-score = -infinity
    for i = 1 to k
        if score(i) > best-score
            best-score = score(i)
    for i = k + 1 to n
        if score(i) > best-score
            return i
    return n

PERMUTE-BY-CYCLE(A, n)
    let B[1:n] be a new array
    offset = RANDOM(1, n)
    for i = 1 to n
        dest = i + offset
        if dest > n
            dest = dest - n
        B[dest] = A[i]
    return B

let A[1:20] be a new array
for i = 1 to 20
    A[i] = 10 * i + RANDOM(0, 9)
print A
B = PERMUTE-BY-CYCLE(A, 20)
print B

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.1
PARENT(i)
    // could alternatively use i \\ 2
    return floor(i / 2)

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MIN-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] < A[i]
        smallest = l
    else
        smallest = i
    if r <= A.heap-size and A[r] < A[smallest]
        smallest = r
    if smallest != i
        exchange A[i] with A[smallest]
        MIN-HEAPIFY(A, smallest)

MIN-HEAP-MINIMUM(A)
    if A.heap-size < 1
        error "heap underflow"
    return A[1]

BUILD-MIN-HEAP(A, n)
    A.heap-size = n
    for i = PARENT(n) downto 1
        MIN-HEAPIFY(A, i)

EXTRACT-MIN(A)
    min = A[1]
    A[1] = A[A.heap-size]
    A.heap-size = A.heap-size - 1
    MIN-HEAPIFY(A, 1)
    return min

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MAX-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] > A[i]
        largest = l
    else largest = i
    if r <= A.heap-size and A[r] > A[largest]
        largest = r
    if largest != i
        exchange A[i] with A[largest]
        MAX-HEAPIFY(A, largest)

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.4
HEAPSORT(A, n)
    BUILD-MAX-HEAP(A, n)
    for i = n downto 2
        exchange A[1] with A[i]
        A.heap-size = A.heap-size - 1
        MAX-HEAPIFY(A, 1)

PARTITION(A, p, r)
    x = A[r]
    i = p - 1
    for j = p to r - 1
        if A[j] <= x
            i = i + 1
            exchange A[i] with A[j]
    exchange A[i + 1] with A[r]
    return i + 1

QUICKSORT(A, p, r)
    if p < r
        q = PARTITION(A, p, r)
        QUICKSORT(A, p, q - 1)
        QUICKSORT(A, q + 1, r)

COUNTING-SORT(A, n, k)
    let B[1:n] and C[0:k] be new arrays
    for i = 0 to k
        C[i] = 0
    for j = 1 to n
        C[A[j]] = C[A[j]] + 1
    // C[i] now contains the number of elements equal to i
    for i = 1 to k
        C[i] = C[i] + C[i - 1]
    // C[i] now contains the number of elements less than or equal to i
    // Copy A to B, starting from the enf od A
    for j = n downto 1
        B[C[A[j]]] = A[j]
        C[A[j]] = C[A[j]] - 1 // to handle duplicate values
    return B

LIST-INSERT(x, y)
    x.next = y.next
    x.prev = y
    if y.next != NIL
        y.next.prev = x
    y.next = x

LIST-INSERT'(x, y)
    x.next = y.next
    x.prev = y
    y.next.prev = x
    y.next = x

LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-SEARCH'(L, k)
    L.nil.key = k
    x = L.nil.next
    while x.key != k
        x = x.next
    if x == L.nil
        return NIL
    else return x

ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

STACK-EMPTY(S)
    if S.top == 0
        return TRUE
    else return FALSE

PUSH(S, x)
    if S.top == S.size
        error "overflow"
    else
        S.top = S.top + 1
        S[S.top] = x

POP(S)
    if STACK-EMPTY(S)
        error "underflow"
    else
        S.top = S.top - 1
        return S[S.top + 1]

// section 11.2

// linked list algorithms
LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-DELETE(L, x)
    if x.prev != NIL
        x.prev.next = x.next
    else L.head = x.next
    if x.next != NIL
        x.next.prev = x.prev

// dummy hash function impl.
h(x)
    return x

CHAINED-HASH-INSERT(T, k, x)
    let N[NIL,NIL,k,x] be a new listnode
    LIST-PREPEND(T[h(N.key)], N)

CHAINED-HASH-SEARCH(T, k)
    found = LIST-SEARCH(T[h(k)], k)
    if found != NIL
        return found.value
    else return NIL

CHAINED-HASH-DELETE(T, k)
    subject = LIST-SEARCH(T[h(k)], k)
    LIST-DELETE(T[h(k)], subject)

INORDER-TREE-WALK(x)
    if x != NIL
        INORDER-TREE-WALK(x.left)
        print x.key
        INORDER-TREE-WALK(x.right)

TREE-SEARCH(x, k)
    if x == NIL or k == x.key
        return x
    if k < x.key
        return TREE-SEARCH(x.left, k)
    else return TREE-SEARCH(x.right, k)

ITERATIVE-TREE-SEARCH(x, k)
    while x != NIL and k != x.key
        if k < x.key
            x = x.left
        else x = x.right
    return x

TREE-MINIMUM(x)
    while x.left != NIL
        x = x.left
    return x

TREE-MAXIMUM(x)
    while x.right != NIL
        x = x.right
    return x

TREE-INSERT(T, z)
    x = T.root
    y = NIL
    while x != NIL
        y = x
        if z.key < x.key
            x = x.left
        else x = x.right
    z.p = y
    if y == NIL
        T.root = z
    else if z.key < y.key
        y.left = z
    else y.right = z

TRANSPLANT(T, u, v)
    if u.p == NIL
        T.root = v
    else if u == u.p.left
        u.p.left = v
    else u.p.right = v
    if v != NIL
        v.p = u.p

TREE-DELETE(T, z)
    if z.left == NIL
        TRANSPLANT(T, z, z.right)
    else if z.right == NIL
        TRANSPLANT(T, z, z.left)
    else y = TREE-MINIMUM(z.right)
        if y != z.right
            TRANSPLANT(T, y, y.right)
            y.right = z.right
            y.right.p = y
        TRANSPLANT(T, z, y);
        y.left = z.left
        y.left.p = y

CUT-ROD(p, n)
    if n == 0
        return 0
    q = -$\infty$
    for i = 1 to n
        q = max(q, p[i] + CUT-ROD(p, n - i))
    return q

MEMOIZED-CUT-ROD(p, n)
    let r[0:n] be a new array
    for i = 0 to n
        r[i] = -$\infty$
    return MEMOIZED-CUT-ROD-AUX(p, n, r)

MEMOIZED-CUT-ROD-AUX(p, n, r)
    if r[n] >= 0
        return r[n]
    if n == 0
        q = 0
    else q = -$\infty$
        for i = 1 to n
            q = max(q, p[i] + MEMOIZED-CUT-ROD(p, n - i, r))
    r[n] = q
    return q

BOTTOM-UP-CUT-ROD(p, n)
    let r[0:n] be a new array
    r[0] = 0
    for j = 1 to n
        q = -$\infty$
        for i = 1 to j
            q = max(q, p[i] + r[j - i])
        r[j] = q
    return r[n]

let prices[1:10] be a new array
prices[1] = 1
prices[2] = 5
prices[3] = 8
prices[4] = 9
prices[5] = 12
prices[6] = 17
prices[7] = 17
prices[8] = 20
prices[9] = 24
prices[10] = 30
n = 4
max-price = CUT-ROD(prices, n)
print max-price

// Priority Queues
LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

PARENT(i)
    return i / 2

INSERT(Q, u)
    Q.heap-size = Q.heap-size + 1
    Q[Q.heap-size] = u
    DECREASE-KEY(Q, u, u.d)

MIN-HEAPIFY(Q, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= Q.heap-size and Q[l].d < Q[i].d
        smallest = l
    else
        smallest = i
    if r <= Q.heap-size and Q[r].d < Q[smallest].d
        smallest = r
    if smallest != i
        exchange Q[i] with Q[smallest]
        MIN-HEAPIFY(Q, smallest)

EXTRACT-MIN(Q)
    min = Q[1]
    Q[1] = Q[Q.heap-size]
    Q.heap-size = Q.heap-size - 1
    MIN-HEAPIFY(Q, 1)
    return min

DECREASE-KEY(Q, v, k)
    for i = 1 to Q.heap-size
        // key will have already been adjusted by RELAX
        if Q[i].key == v.key
            Q[i].d = k
            exchange Q[i] with Q[1]
            MIN-HEAPIFY(Q, 1)

INITIALIZE-SINGLE-SOURCE(G, s)
    for each vertex v in G.V
        v.d = $\infty$
        v.$\pi$ = NIL
    s.d = 0

RELAX(u, v, w)
    if v.d > u.d + w(u, v)
        v.d = u.d + w(u, v)
        v.$\pi$ = u
        return TRUE
    return FALSE

SET-UNION(s, v)
    return s + v

DIJKSTRA(G, w, s)
    INITIALIZE-SINGLE-SOURCE(G, s);
    let S be a new set
    let Q[len(G.V)] be a new priorityqueue
    for each vertex v in G.V
        INSERT(Q, v)
    while Q
        u = EXTRACT-MIN(Q)
        S = S | {u}
        for each vertex v in G.Adj(u)
            did-decrease = RELAX(u, v, w)
            if did-decrease
                DECREASE-KEY(Q, v, v.d)


DIJKSTRA-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 10
    adj-mat[1][4] = 5
    adj-mat[2][3] = 1
    adj-mat[2][4] = 2
    adj-mat[3][5] = 4
    adj-mat[4][2] = 3
    adj-mat[4][3] = 9
    adj-mat[4][5] = 2
    adj-mat[5][3] = 6

    w(u, v)
        return adj-mat[u.key][v.key]

    let G[adj-mat] be a new graph
    DIJKSTRA(G, w, G.V[1])
    print "done"

    for each u in G.V
        print u

DIJKSTRA-EXAMPLE()

// Queue operations
ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

BFS(G, s)
    // for each vertex u in G.V - {s}
    for each vertex u in G.V
        if u == s
            continue
        u.color = WHITE
        u.d = $\infty$
        u.$\pi$ = NIL
    s.color = GRAY
    s.d = 0
    s.$\pi$ = NIL
    let Q[len(G.V) + 1] be a new queue
    ENQUEUE(Q, s)
    while len(Q) > 0
        u = DEQUEUE(Q)
        for each vertex v in G.Adj(u)
            if v.color == WHITE
                v.color = GRAY
                v.d = u.d + 1
                v.$\pi$ = u
                ENQUEUE(Q, v)
        u.color = BLACK

BFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    BFS(G, G.V[1])
    for each u in G.V
        print u

DFS(G)
    for each vertex u in G.V
        u.color = WHITE
        u.$\pi$ = NIL
    time = 0
    for each vertex u in G.V
        if u.color == WHITE
            DFS-VISIT(G, u, time)

DFS-VISIT(G, u, time)
    time = time + 1
    u.d = time
    u.color = GRAY
    for each vertex v in G.Adj(u)
        if v.color == WHITE
            v.$\pi$ = u
            DFS-VISIT(G, v, time)
    u.color = BLACK
    time = time + 1
    u.f = time

DFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    DFS(G)
    for each u in G.V
        print str(u) + " f=" + str(u.f)

BUBBLESORT(A, n)
    for i = 1 to n - 1
        for j = n downto i + 1
            if A[j] < A[j - 1]
                exchange A[j] with A[j - 1]

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

A = [5, 4, 3, 2, 1]
print A
INSERTION-SORT(A, 5)
print A

MERGE(A, p, q, r)
    // this is a comment
    n$_L$ = q - p + 1
    n$_R$ = r - q
    let L[0:n$_L$ - 1] and R[0:n$_R$ - 1] be new arrays
    for i = 0 to n$_L$ - 1
        L[i] = A[p + i]
    for j = 0 to n$_R$ - 1
        R[j] = A[q + j + 1]
    i = 0
    j = 0
    k = p
    while i < n$_L$ and j < n$_R$
        if L[i] <= R[j]
            A[k] = L[i]
            i = i + 1
        else A[k] = R[j]
            j = j + 1
        k = k + 1
    while i < n$_L$
        A[k] = L[i]
        i = i + 1
        k = k + 1
    while j < n$_R$
        A[k] = R[j]
        j = j + 1
        k = k + 1

let A[1:10] be a new array
for i = 1 to 5
    A[i] = i + 10
    A[i + 5] = i + 10

print A
MERGE(A, 1, 5, 10)
print A

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

let A$_l$[1:5] be a new array
for i = 1 to 5
    A$_l$[i] = 6 - i
print A$_l$
INSERTION-SORT(A$_l$, 5)
print A$_l$

MATRIX-MULTIPLY(A, B, C, n)
    for i = 1 to n
        for j = 1 to n
            for k = 1 to n
                C[i][j] = C[i][j] + A[i][k] * B[k][j]

ONLINE-MAXIMUM(k, n)
    best-score = -infinity
    for i = 1 to k
        if score(i) > best-score
            best-score = score(i)
    for i = k + 1 to n
        if score(i) > best-score
            return i
    return n

PERMUTE-BY-CYCLE(A, n)
    let B[1:n] be a new array
    offset = RANDOM(1, n)
    for i = 1 to n
        dest = i + offset
        if dest > n
            dest = dest - n
        B[dest] = A[i]
    return B

let A[1:20] be a new array
for i = 1 to 20
    A[i] = 10 * i + RANDOM(0, 9)
print A
B = PERMUTE-BY-CYCLE(A, 20)
print B

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.1
PARENT(i)
    // could alternatively use i \\ 2
    return floor(i / 2)

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MIN-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] < A[i]
        smallest = l
    else
        smallest = i
    if r <= A.heap-size and A[r] < A[smallest]
        smallest = r
    if smallest != i
        exchange A[i] with A[smallest]
        MIN-HEAPIFY(A, smallest)

MIN-HEAP-MINIMUM(A)
    if A.heap-size < 1
        error "heap underflow"
    return A[1]

BUILD-MIN-HEAP(A, n)
    A.heap-size = n
    for i = PARENT(n) downto 1
        MIN-HEAPIFY(A, i)

EXTRACT-MIN(A)
    min = A[1]
    A[1] = A[A.heap-size]
    A.heap-size = A.heap-size - 1
    MIN-HEAPIFY(A, 1)
    return min

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MAX-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] > A[i]
        largest = l
    else largest = i
    if r <= A.heap-size and A[r] > A[largest]
        largest = r
    if largest != i
        exchange A[i] with A[largest]
        MAX-HEAPIFY(A, largest)

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.4
HEAPSORT(A, n)
    BUILD-MAX-HEAP(A, n)
    for i = n downto 2
        exchange A[1] with A[i]
        A.heap-size = A.heap-size - 1
        MAX-HEAPIFY(A, 1)

PARTITION(A, p, r)
    x = A[r]
    i = p - 1
    for j = p to r - 1
        if A[j] <= x
            i = i + 1
            exchange A[i] with A[j]
    exchange A[i + 1] with A[r]
    return i + 1

QUICKSORT(A, p, r)
    if p < r
        q = PARTITION(A, p, r)
        QUICKSORT(A, p, q - 1)
        QUICKSORT(A, q + 1, r)

COUNTING-SORT(A, n, k)
    let B[1:n] and C[0:k] be new arrays
    for i = 0 to k
        C[i] = 0
    for j = 1 to n
        C[A[j]] = C[A[j]] + 1
    // C[i] now contains the number of elements equal to i
    for i = 1 to k
        C[i] = C[i] + C[i - 1]
    // C[i] now contains the number of elements less than or equal to i
    // Copy A to B, starting from the enf od A
    for j = n downto 1
        B[C[A[j]]] = A[j]
        C[A[j]] = C[A[j]] - 1 // to handle duplicate values
    return B

LIST-INSERT(x, y)
    x.next = y.next
    x.prev = y
    if y.next != NIL
        y.next.prev = x
    y.next = x

LIST-INSERT'(x, y)
    x.next = y.next
    x.prev = y
    y.next.prev = x
    y.next = x

LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-SEARCH'(L, k)
    L.nil.key = k
    x = L.nil.next
    while x.key != k
        x = x.next
    if x == L.nil
        return NIL
    else return x

ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

STACK-EMPTY(S)
    if S.top == 0
        return TRUE
    else return FALSE

PUSH(S, x)
    if S.top == S.size
        error "overflow"
    else
        S.top = S.top + 1
        S[S.top] = x

POP(S)
    if STACK-EMPTY(S)
        error "underflow"
    else
        S.top = S.top - 1
        return S[S.top + 1]

// section 11.2

// linked list algorithms
LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-DELETE(L, x)
    if x.prev != NIL
        x.prev.next = x.next
    else L.head = x.next
    if x.next != NIL
        x.next.prev = x.prev

// dummy hash function impl.
h(x)
    return x

CHAINED-HASH-INSERT(T, k, x)
    let N[NIL,NIL,k,x] be a new listnode
    LIST-PREPEND(T[h(N.key)], N)

CHAINED-HASH-SEARCH(T, k)
    found = LIST-SEARCH(T[h(k)], k)
    if found != NIL
        return found.value
    else return NIL

CHAINED-HASH-DELETE(T, k)
    subject = LIST-SEARCH(T[h(k)], k)
    LIST-DELETE(T[h(k)], subject)

INORDER-TREE-WALK(x)
    if x != NIL
        INORDER-TREE-WALK(x.left)
        print x.key
        INORDER-TREE-WALK(x.right)

TREE-SEARCH(x, k)
    if x == NIL or k == x.key
        return x
    if k < x.key
        return TREE-SEARCH(x.left, k)
    else return TREE-SEARCH(x.right, k)

ITERATIVE-TREE-SEARCH(x, k)
    while x != NIL and k != x.key
        if k < x.key
            x = x.left
        else x = x.right
    return x

TREE-MINIMUM(x)
    while x.left != NIL
        x = x.left
    return x

TREE-MAXIMUM(x)
    while x.right != NIL
        x = x.right
    return x

TREE-INSERT(T, z)
    x = T.root
    y = NIL
    while x != NIL
        y = x
        if z.key < x.key
            x = x.left
        else x = x.right
    z.p = y
    if y == NIL
        T.root = z
    else if z.key < y.key
        y.left = z
    else y.right = z

TRANSPLANT(T, u, v)
    if u.p == NIL
        T.root = v
    else if u == u.p.left
        u.p.left = v
    else u.p.right = v
    if v != NIL
        v.p = u.p

TREE-DELETE(T, z)
    if z.left == NIL
        TRANSPLANT(T, z, z.right)
    else if z.right == NIL
        TRANSPLANT(T, z, z.left)
    else y = TREE-MINIMUM(z.right)
        if y != z.right
            TRANSPLANT(T, y, y.right)
            y.right = z.right
            y.right.p = y
        TRANSPLANT(T, z, y);
        y.left = z.left
        y.left.p = y

CUT-ROD(p, n)
    if n == 0
        return 0
    q = -$\infty$
    for i = 1 to n
        q = max(q, p[i] + CUT-ROD(p, n - i))
    return q

MEMOIZED-CUT-ROD(p, n)
    let r[0:n] be a new array
    for i = 0 to n
        r[i] = -$\infty$
    return MEMOIZED-CUT-ROD-AUX(p, n, r)

MEMOIZED-CUT-ROD-AUX(p, n, r)
    if r[n] >= 0
        return r[n]
    if n == 0
        q = 0
    else q = -$\infty$
        for i = 1 to n
            q = max(q, p[i] + MEMOIZED-CUT-ROD(p, n - i, r))
    r[n] = q
    return q

BOTTOM-UP-CUT-ROD(p, n)
    let r[0:n] be a new array
    r[0] = 0
    for j = 1 to n
        q = -$\infty$
        for i = 1 to j
            q = max(q, p[i] + r[j - i])
        r[j] = q
    return r[n]

let prices[1:10] be a new array
prices[1] = 1
prices[2] = 5
prices[3] = 8
prices[4] = 9
prices[5] = 12
prices[6] = 17
prices[7] = 17
prices[8] = 20
prices[9] = 24
prices[10] = 30
n = 4
max-price = CUT-ROD(prices, n)
print max-price

// Priority Queues
LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

PARENT(i)
    return i / 2

INSERT(Q, u)
    Q.heap-size = Q.heap-size + 1
    Q[Q.heap-size] = u
    DECREASE-KEY(Q, u, u.d)

MIN-HEAPIFY(Q, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= Q.heap-size and Q[l].d < Q[i].d
        smallest = l
    else
        smallest = i
    if r <= Q.heap-size and Q[r].d < Q[smallest].d
        smallest = r
    if smallest != i
        exchange Q[i] with Q[smallest]
        MIN-HEAPIFY(Q, smallest)

EXTRACT-MIN(Q)
    min = Q[1]
    Q[1] = Q[Q.heap-size]
    Q.heap-size = Q.heap-size - 1
    MIN-HEAPIFY(Q, 1)
    return min

DECREASE-KEY(Q, v, k)
    for i = 1 to Q.heap-size
        // key will have already been adjusted by RELAX
        if Q[i].key == v.key
            Q[i].d = k
            exchange Q[i] with Q[1]
            MIN-HEAPIFY(Q, 1)

INITIALIZE-SINGLE-SOURCE(G, s)
    for each vertex v in G.V
        v.d = $\infty$
        v.$\pi$ = NIL
    s.d = 0

RELAX(u, v, w)
    if v.d > u.d + w(u, v)
        v.d = u.d + w(u, v)
        v.$\pi$ = u
        return TRUE
    return FALSE

SET-UNION(s, v)
    return s + v

DIJKSTRA(G, w, s)
    INITIALIZE-SINGLE-SOURCE(G, s);
    let S be a new set
    let Q[len(G.V)] be a new priorityqueue
    for each vertex v in G.V
        INSERT(Q, v)
    while Q
        u = EXTRACT-MIN(Q)
        S = S | {u}
        for each vertex v in G.Adj(u)
            did-decrease = RELAX(u, v, w)
            if did-decrease
                DECREASE-KEY(Q, v, v.d)


DIJKSTRA-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 10
    adj-mat[1][4] = 5
    adj-mat[2][3] = 1
    adj-mat[2][4] = 2
    adj-mat[3][5] = 4
    adj-mat[4][2] = 3
    adj-mat[4][3] = 9
    adj-mat[4][5] = 2
    adj-mat[5][3] = 6

    w(u, v)
        return adj-mat[u.key][v.key]

    let G[adj-mat] be a new graph
    DIJKSTRA(G, w, G.V[1])
    print "done"

    for each u in G.V
        print u

DIJKSTRA-EXAMPLE()

// Queue operations
ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

BFS(G, s)
    // for each vertex u in G.V - {s}
    for each vertex u in G.V
        if u == s
            continue
        u.color = WHITE
        u.d = $\infty$
        u.$\pi$ = NIL
    s.color = GRAY
    s.d = 0
    s.$\pi$ = NIL
    let Q[len(G.V) + 1] be a new queue
    ENQUEUE(Q, s)
    while len(Q) > 0
        u = DEQUEUE(Q)
        for each vertex v in G.Adj(u)
            if v.color == WHITE
                v.color = GRAY
                v.d = u.d + 1
                v.$\pi$ = u
                ENQUEUE(Q, v)
        u.color = BLACK

BFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    BFS(G, G.V[1])
    for each u in G.V
        print u

DFS(G)
    for each vertex u in G.V
        u.color = WHITE
        u.$\pi$ = NIL
    time = 0
    for each vertex u in G.V
        if u.color == WHITE
            DFS-VISIT(G, u, time)

DFS-VISIT(G, u, time)
    time = time + 1
    u.d = time
    u.color = GRAY
    for each vertex v in G.Adj(u)
        if v.color == WHITE
            v.$\pi$ = u
            DFS-VISIT(G, v, time)
    u.color = BLACK
    time = time + 1
    u.f = time

DFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    DFS(G)
    for each u in G.V
        print str(u) + " f=" + str(u.f)

BUBBLESORT(A, n)
    for i = 1 to n - 1
        for j = n downto i + 1
            if A[j] < A[j - 1]
                exchange A[j] with A[j - 1]

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

A = [5, 4, 3, 2, 1]
print A
INSERTION-SORT(A, 5)
print A

MERGE(A, p, q, r)
    // this is a comment
    n$_L$ = q - p + 1
    n$_R$ = r - q
    let L[0:n$_L$ - 1] and R[0:n$_R$ - 1] be new arrays
    for i = 0 to n$_L$ - 1
        L[i] = A[p + i]
    for j = 0 to n$_R$ - 1
        R[j] = A[q + j + 1]
    i = 0
    j = 0
    k = p
    while i < n$_L$ and j < n$_R$
        if L[i] <= R[j]
            A[k] = L[i]
            i = i + 1
        else A[k] = R[j]
            j = j + 1
        k = k + 1
    while i < n$_L$
        A[k] = L[i]
        i = i + 1
        k = k + 1
    while j < n$_R$
        A[k] = R[j]
        j = j + 1
        k = k + 1

let A[1:10] be a new array
for i = 1 to 5
    A[i] = i + 10
    A[i + 5] = i + 10

print A
MERGE(A, 1, 5, 10)
print A

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

let A$_l$[1:5] be a new array
for i = 1 to 5
    A$_l$[i] = 6 - i
print A$_l$
INSERTION-SORT(A$_l$, 5)
print A$_l$

MATRIX-MULTIPLY(A, B, C, n)
    for i = 1 to n
        for j = 1 to n
            for k = 1 to n
                C[i][j] = C[i][j] + A[i][k] * B[k][j]

ONLINE-MAXIMUM(k, n)
    best-score = -infinity
    for i = 1 to k
        if score(i) > best-score
            best-score = score(i)
    for i = k + 1 to n
        if score(i) > best-score
            return i
    return n

PERMUTE-BY-CYCLE(A, n)
    let B[1:n] be a new array
    offset = RANDOM(1, n)
    for i = 1 to n
        dest = i + offset
        if dest > n
            dest = dest - n
        B[dest] = A[i]
    return B

let A[1:20] be a new array
for i = 1 to 20
    A[i] = 10 * i + RANDOM(0, 9)
print A
B = PERMUTE-BY-CYCLE(A, 20)
print B

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.1
PARENT(i)
    // could alternatively use i \\ 2
    return floor(i / 2)

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MIN-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] < A[i]
        smallest = l
    else
        smallest = i
    if r <= A.heap-size and A[r] < A[smallest]
        smallest = r
    if smallest != i
        exchange A[i] with A[smallest]
        MIN-HEAPIFY(A, smallest)

MIN-HEAP-MINIMUM(A)
    if A.heap-size < 1
        error "heap underflow"
    return A[1]

BUILD-MIN-HEAP(A, n)
    A.heap-size = n
    for i = PARENT(n) downto 1
        MIN-HEAPIFY(A, i)

EXTRACT-MIN(A)
    min = A[1]
    A[1] = A[A.heap-size]
    A.heap-size = A.heap-size - 1
    MIN-HEAPIFY(A, 1)
    return min

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MAX-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] > A[i]
        largest = l
    else largest = i
    if r <= A.heap-size and A[r] > A[largest]
        largest = r
    if largest != i
        exchange A[i] with A[largest]
        MAX-HEAPIFY(A, largest)

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.4
HEAPSORT(A, n)
    BUILD-MAX-HEAP(A, n)
    for i = n downto 2
        exchange A[1] with A[i]
        A.heap-size = A.heap-size - 1
        MAX-HEAPIFY(A, 1)

PARTITION(A, p, r)
    x = A[r]
    i = p - 1
    for j = p to r - 1
        if A[j] <= x
            i = i + 1
            exchange A[i] with A[j]
    exchange A[i + 1] with A[r]
    return i + 1

QUICKSORT(A, p, r)
    if p < r
        q = PARTITION(A, p, r)
        QUICKSORT(A, p, q - 1)
        QUICKSORT(A, q + 1, r)

COUNTING-SORT(A, n, k)
    let B[1:n] and C[0:k] be new arrays
    for i = 0 to k
        C[i] = 0
    for j = 1 to n
        C[A[j]] = C[A[j]] + 1
    // C[i] now contains the number of elements equal to i
    for i = 1 to k
        C[i] = C[i] + C[i - 1]
    // C[i] now contains the number of elements less than or equal to i
    // Copy A to B, starting from the enf od A
    for j = n downto 1
        B[C[A[j]]] = A[j]
        C[A[j]] = C[A[j]] - 1 // to handle duplicate values
    return B

LIST-INSERT(x, y)
    x.next = y.next
    x.prev = y
    if y.next != NIL
        y.next.prev = x
    y.next = x

LIST-INSERT'(x, y)
    x.next = y.next
    x.prev = y
    y.next.prev = x
    y.next = x

LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-SEARCH'(L, k)
    L.nil.key = k
    x = L.nil.next
    while x.key != k
        x = x.next
    if x == L.nil
        return NIL
    else return x

ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

STACK-EMPTY(S)
    if S.top == 0
        return TRUE
    else return FALSE

PUSH(S, x)
    if S.top == S.size
        error "overflow"
    else
        S.top = S.top + 1
        S[S.top] = x

POP(S)
    if STACK-EMPTY(S)
        error "underflow"
    else
        S.top = S.top - 1
        return S[S.top + 1]

// section 11.2

// linked list algorithms
LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-DELETE(L, x)
    if x.prev != NIL
        x.prev.next = x.next
    else L.head = x.next
    if x.next != NIL
        x.next.prev = x.prev

// dummy hash function impl.
h(x)
    return x

CHAINED-HASH-INSERT(T, k, x)
    let N[NIL,NIL,k,x] be a new listnode
    LIST-PREPEND(T[h(N.key)], N)

CHAINED-HASH-SEARCH(T, k)
    found = LIST-SEARCH(T[h(k)], k)
    if found != NIL
        return found.value
    else return NIL

CHAINED-HASH-DELETE(T, k)
    subject = LIST-SEARCH(T[h(k)], k)
    LIST-DELETE(T[h(k)], subject)

INORDER-TREE-WALK(x)
    if x != NIL
        INORDER-TREE-WALK(x.left)
        print x.key
        INORDER-TREE-WALK(x.right)

TREE-SEARCH(x, k)
    if x == NIL or k == x.key
        return x
    if k < x.key
        return TREE-SEARCH(x.left, k)
    else return TREE-SEARCH(x.right, k)

ITERATIVE-TREE-SEARCH(x, k)
    while x != NIL and k != x.key
        if k < x.key
            x = x.left
        else x = x.right
    return x

TREE-MINIMUM(x)
    while x.left != NIL
        x = x.left
    return x

TREE-MAXIMUM(x)
    while x.right != NIL
        x = x.right
    return x

TREE-INSERT(T, z)
    x = T.root
    y = NIL
    while x != NIL
        y = x
        if z.key < x.key
            x = x.left
        else x = x.right
    z.p = y
    if y == NIL
        T.root = z
    else if z.key < y.key
        y.left = z
    else y.right = z

TRANSPLANT(T, u, v)
    if u.p == NIL
        T.root = v
    else if u == u.p.left
        u.p.left = v
    else u.p.right = v
    if v != NIL
        v.p = u.p

TREE-DELETE(T, z)
    if z.left == NIL
        TRANSPLANT(T, z, z.right)
    else if z.right == NIL
        TRANSPLANT(T, z, z.left)
    else y = TREE-MINIMUM(z.right)
        if y != z.right
            TRANSPLANT(T, y, y.right)
            y.right = z.right
            y.right.p = y
        TRANSPLANT(T, z, y);
        y.left = z.left
        y.left.p = y

CUT-ROD(p, n)
    if n == 0
        return 0
    q = -$\infty$
    for i = 1 to n
        q = max(q, p[i] + CUT-ROD(p, n - i))
    return q

MEMOIZED-CUT-ROD(p, n)
    let r[0:n] be a new array
    for i = 0 to n
        r[i] = -$\infty$
    return MEMOIZED-CUT-ROD-AUX(p, n, r)

MEMOIZED-CUT-ROD-AUX(p, n, r)
    if r[n] >= 0
        return r[n]
    if n == 0
        q = 0
    else q = -$\infty$
        for i = 1 to n
            q = max(q, p[i] + MEMOIZED-CUT-ROD(p, n - i, r))
    r[n] = q
    return q

BOTTOM-UP-CUT-ROD(p, n)
    let r[0:n] be a new array
    r[0] = 0
    for j = 1 to n
        q = -$\infty$
        for i = 1 to j
            q = max(q, p[i] + r[j - i])
        r[j] = q
    return r[n]

let prices[1:10] be a new array
prices[1] = 1
prices[2] = 5
prices[3] = 8
prices[4] = 9
prices[5] = 12
prices[6] = 17
prices[7] = 17
prices[8] = 20
prices[9] = 24
prices[10] = 30
n = 4
max-price = CUT-ROD(prices, n)
print max-price

// Priority Queues
LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

PARENT(i)
    return i / 2

INSERT(Q, u)
    Q.heap-size = Q.heap-size + 1
    Q[Q.heap-size] = u
    DECREASE-KEY(Q, u, u.d)

MIN-HEAPIFY(Q, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= Q.heap-size and Q[l].d < Q[i].d
        smallest = l
    else
        smallest = i
    if r <= Q.heap-size and Q[r].d < Q[smallest].d
        smallest = r
    if smallest != i
        exchange Q[i] with Q[smallest]
        MIN-HEAPIFY(Q, smallest)

EXTRACT-MIN(Q)
    min = Q[1]
    Q[1] = Q[Q.heap-size]
    Q.heap-size = Q.heap-size - 1
    MIN-HEAPIFY(Q, 1)
    return min

DECREASE-KEY(Q, v, k)
    for i = 1 to Q.heap-size
        // key will have already been adjusted by RELAX
        if Q[i].key == v.key
            Q[i].d = k
            exchange Q[i] with Q[1]
            MIN-HEAPIFY(Q, 1)

INITIALIZE-SINGLE-SOURCE(G, s)
    for each vertex v in G.V
        v.d = $\infty$
        v.$\pi$ = NIL
    s.d = 0

RELAX(u, v, w)
    if v.d > u.d + w(u, v)
        v.d = u.d + w(u, v)
        v.$\pi$ = u
        return TRUE
    return FALSE

SET-UNION(s, v)
    return s + v

DIJKSTRA(G, w, s)
    INITIALIZE-SINGLE-SOURCE(G, s);
    let S be a new set
    let Q[len(G.V)] be a new priorityqueue
    for each vertex v in G.V
        INSERT(Q, v)
    while Q
        u = EXTRACT-MIN(Q)
        S = S | {u}
        for each vertex v in G.Adj(u)
            did-decrease = RELAX(u, v, w)
            if did-decrease
                DECREASE-KEY(Q, v, v.d)


DIJKSTRA-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 10
    adj-mat[1][4] = 5
    adj-mat[2][3] = 1
    adj-mat[2][4] = 2
    adj-mat[3][5] = 4
    adj-mat[4][2] = 3
    adj-mat[4][3] = 9
    adj-mat[4][5] = 2
    adj-mat[5][3] = 6

    w(u, v)
        return adj-mat[u.key][v.key]

    let G[adj-mat] be a new graph
    DIJKSTRA(G, w, G.V[1])
    print "done"

    for each u in G.V
        print u

DIJKSTRA-EXAMPLE()

// Queue operations
ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

BFS(G, s)
    // for each vertex u in G.V - {s}
    for each vertex u in G.V
        if u == s
            continue
        u.color = WHITE
        u.d = $\infty$
        u.$\pi$ = NIL
    s.color = GRAY
    s.d = 0
    s.$\pi$ = NIL
    let Q[len(G.V) + 1] be a new queue
    ENQUEUE(Q, s)
    while len(Q) > 0
        u = DEQUEUE(Q)
        for each vertex v in G.Adj(u)
            if v.color == WHITE
                v.color = GRAY
                v.d = u.d + 1
                v.$\pi$ = u
                ENQUEUE(Q, v)
        u.color = BLACK

BFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    BFS(G, G.V[1])
    for each u in G.V
        print u

DFS(G)
    for each vertex u in G.V
        u.color = WHITE
        u.$\pi$ = NIL
    time = 0
    for each vertex u in G.V
        if u.color == WHITE
            DFS-VISIT(G, u, time)

DFS-VISIT(G, u, time)
    time = time + 1
    u.d = time
    u.color = GRAY
    for each vertex v in G.Adj(u)
        if v.color == WHITE
            v.$\pi$ = u
            DFS-VISIT(G, v, time)
    u.color = BLACK
    time = time + 1
    u.f = time

DFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    DFS(G)
    for each u in G.V
        print str(u) + " f=" + str(u.f)

BUBBLESORT(A, n)
    for i = 1 to n - 1
        for j = n downto i + 1
            if A[j] < A[j - 1]
                exchange A[j] with A[j - 1]

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

A = [5, 4, 3, 2, 1]
print A
INSERTION-SORT(A, 5)
print A

MERGE(A, p, q, r)
    // this is a comment
    n$_L$ = q - p + 1
    n$_R$ = r - q
    let L[0:n$_L$ - 1] and R[0:n$_R$ - 1] be new arrays
    for i = 0 to n$_L$ - 1
        L[i] = A[p + i]
    for j = 0 to n$_R$ - 1
        R[j] = A[q + j + 1]
    i = 0
    j = 0
    k = p
    while i < n$_L$ and j < n$_R$
        if L[i] <= R[j]
            A[k] = L[i]
            i = i + 1
        else A[k] = R[j]
            j = j + 1
        k = k + 1
    while i < n$_L$
        A[k] = L[i]
        i = i + 1
        k = k + 1
    while j < n$_R$
        A[k] = R[j]
        j = j + 1
        k = k + 1

let A[1:10] be a new array
for i = 1 to 5
    A[i] = i + 10
    A[i + 5] = i + 10

print A
MERGE(A, 1, 5, 10)
print A

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

let A$_l$[1:5] be a new array
for i = 1 to 5
    A$_l$[i] = 6 - i
print A$_l$
INSERTION-SORT(A$_l$, 5)
print A$_l$

MATRIX-MULTIPLY(A, B, C, n)
    for i = 1 to n
        for j = 1 to n
            for k = 1 to n
                C[i][j] = C[i][j] + A[i][k] * B[k][j]

ONLINE-MAXIMUM(k, n)
    best-score = -infinity
    for i = 1 to k
        if score(i) > best-score
            best-score = score(i)
    for i = k + 1 to n
        if score(i) > best-score
            return i
    return n

PERMUTE-BY-CYCLE(A, n)
    let B[1:n] be a new array
    offset = RANDOM(1, n)
    for i = 1 to n
        dest = i + offset
        if dest > n
            dest = dest - n
        B[dest] = A[i]
    return B

let A[1:20] be a new array
for i = 1 to 20
    A[i] = 10 * i + RANDOM(0, 9)
print A
B = PERMUTE-BY-CYCLE(A, 20)
print B

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.1
PARENT(i)
    // could alternatively use i \\ 2
    return floor(i / 2)

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MIN-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] < A[i]
        smallest = l
    else
        smallest = i
    if r <= A.heap-size and A[r] < A[smallest]
        smallest = r
    if smallest != i
        exchange A[i] with A[smallest]
        MIN-HEAPIFY(A, smallest)

MIN-HEAP-MINIMUM(A)
    if A.heap-size < 1
        error "heap underflow"
    return A[1]

BUILD-MIN-HEAP(A, n)
    A.heap-size = n
    for i = PARENT(n) downto 1
        MIN-HEAPIFY(A, i)

EXTRACT-MIN(A)
    min = A[1]
    A[1] = A[A.heap-size]
    A.heap-size = A.heap-size - 1
    MIN-HEAPIFY(A, 1)
    return min

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MAX-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] > A[i]
        largest = l
    else largest = i
    if r <= A.heap-size and A[r] > A[largest]
        largest = r
    if largest != i
        exchange A[i] with A[largest]
        MAX-HEAPIFY(A, largest)

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.4
HEAPSORT(A, n)
    BUILD-MAX-HEAP(A, n)
    for i = n downto 2
        exchange A[1] with A[i]
        A.heap-size = A.heap-size - 1
        MAX-HEAPIFY(A, 1)

PARTITION(A, p, r)
    x = A[r]
    i = p - 1
    for j = p to r - 1
        if A[j] <= x
            i = i + 1
            exchange A[i] with A[j]
    exchange A[i + 1] with A[r]
    return i + 1

QUICKSORT(A, p, r)
    if p < r
        q = PARTITION(A, p, r)
        QUICKSORT(A, p, q - 1)
        QUICKSORT(A, q + 1, r)

COUNTING-SORT(A, n, k)
    let B[1:n] and C[0:k] be new arrays
    for i = 0 to k
        C[i] = 0
    for j = 1 to n
        C[A[j]] = C[A[j]] + 1
    // C[i] now contains the number of elements equal to i
    for i = 1 to k
        C[i] = C[i] + C[i - 1]
    // C[i] now contains the number of elements less than or equal to i
    // Copy A to B, starting from the enf od A
    for j = n downto 1
        B[C[A[j]]] = A[j]
        C[A[j]] = C[A[j]] - 1 // to handle duplicate values
    return B

LIST-INSERT(x, y)
    x.next = y.next
    x.prev = y
    if y.next != NIL
        y.next.prev = x
    y.next = x

LIST-INSERT'(x, y)
    x.next = y.next
    x.prev = y
    y.next.prev = x
    y.next = x

LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-SEARCH'(L, k)
    L.nil.key = k
    x = L.nil.next
    while x.key != k
        x = x.next
    if x == L.nil
        return NIL
    else return x

ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

STACK-EMPTY(S)
    if S.top == 0
        return TRUE
    else return FALSE

PUSH(S, x)
    if S.top == S.size
        error "overflow"
    else
        S.top = S.top + 1
        S[S.top] = x

POP(S)
    if STACK-EMPTY(S)
        error "underflow"
    else
        S.top = S.top - 1
        return S[S.top + 1]

// section 11.2

// linked list algorithms
LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-DELETE(L, x)
    if x.prev != NIL
        x.prev.next = x.next
    else L.head = x.next
    if x.next != NIL
        x.next.prev = x.prev

// dummy hash function impl.
h(x)
    return x

CHAINED-HASH-INSERT(T, k, x)
    let N[NIL,NIL,k,x] be a new listnode
    LIST-PREPEND(T[h(N.key)], N)

CHAINED-HASH-SEARCH(T, k)
    found = LIST-SEARCH(T[h(k)], k)
    if found != NIL
        return found.value
    else return NIL

CHAINED-HASH-DELETE(T, k)
    subject = LIST-SEARCH(T[h(k)], k)
    LIST-DELETE(T[h(k)], subject)

INORDER-TREE-WALK(x)
    if x != NIL
        INORDER-TREE-WALK(x.left)
        print x.key
        INORDER-TREE-WALK(x.right)

TREE-SEARCH(x, k)
    if x == NIL or k == x.key
        return x
    if k < x.key
        return TREE-SEARCH(x.left, k)
    else return TREE-SEARCH(x.right, k)

ITERATIVE-TREE-SEARCH(x, k)
    while x != NIL and k != x.key
        if k < x.key
            x = x.left
        else x = x.right
    return x

TREE-MINIMUM(x)
    while x.left != NIL
        x = x.left
    return x

TREE-MAXIMUM(x)
    while x.right != NIL
        x = x.right
    return x

TREE-INSERT(T, z)
    x = T.root
    y = NIL
    while x != NIL
        y = x
        if z.key < x.key
            x = x.left
        else x = x.right
    z.p = y
    if y == NIL
        T.root = z
    else if z.key < y.key
        y.left = z
    else y.right = z

TRANSPLANT(T, u, v)
    if u.p == NIL
        T.root = v
    else if u == u.p.left
        u.p.left = v
    else u.p.right = v
    if v != NIL
        v.p = u.p

TREE-DELETE(T, z)
    if z.left == NIL
        TRANSPLANT(T, z, z.right)
    else if z.right == NIL
        TRANSPLANT(T, z, z.left)
    else y = TREE-MINIMUM(z.right)
        if y != z.right
            TRANSPLANT(T, y, y.right)
            y.right = z.right
            y.right.p = y
        TRANSPLANT(T, z, y);
        y.left = z.left
        y.left.p = y

CUT-ROD(p, n)
    if n == 0
        return 0
    q = -$\infty$
    for i = 1 to n
        q = max(q, p[i] + CUT-ROD(p, n - i))
    return q

MEMOIZED-CUT-ROD(p, n)
    let r[0:n] be a new array
    for i = 0 to n
        r[i] = -$\infty$
    return MEMOIZED-CUT-ROD-AUX(p, n, r)

MEMOIZED-CUT-ROD-AUX(p, n, r)
    if r[n] >= 0
        return r[n]
    if n == 0
        q = 0
    else q = -$\infty$
        for i = 1 to n
            q = max(q, p[i] + MEMOIZED-CUT-ROD(p, n - i, r))
    r[n] = q
    return q

BOTTOM-UP-CUT-ROD(p, n)
    let r[0:n] be a new array
    r[0] = 0
    for j = 1 to n
        q = -$\infty$
        for i = 1 to j
            q = max(q, p[i] + r[j - i])
        r[j] = q
    return r[n]

let prices[1:10] be a new array
prices[1] = 1
prices[2] = 5
prices[3] = 8
prices[4] = 9
prices[5] = 12
prices[6] = 17
prices[7] = 17
prices[8] = 20
prices[9] = 24
prices[10] = 30
n = 4
max-price = CUT-ROD(prices, n)
print max-price

// Priority Queues
LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

PARENT(i)
    return i / 2

INSERT(Q, u)
    Q.heap-size = Q.heap-size + 1
    Q[Q.heap-size] = u
    DECREASE-KEY(Q, u, u.d)

MIN-HEAPIFY(Q, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= Q.heap-size and Q[l].d < Q[i].d
        smallest = l
    else
        smallest = i
    if r <= Q.heap-size and Q[r].d < Q[smallest].d
        smallest = r
    if smallest != i
        exchange Q[i] with Q[smallest]
        MIN-HEAPIFY(Q, smallest)

EXTRACT-MIN(Q)
    min = Q[1]
    Q[1] = Q[Q.heap-size]
    Q.heap-size = Q.heap-size - 1
    MIN-HEAPIFY(Q, 1)
    return min

DECREASE-KEY(Q, v, k)
    for i = 1 to Q.heap-size
        // key will have already been adjusted by RELAX
        if Q[i].key == v.key
            Q[i].d = k
            exchange Q[i] with Q[1]
            MIN-HEAPIFY(Q, 1)

INITIALIZE-SINGLE-SOURCE(G, s)
    for each vertex v in G.V
        v.d = $\infty$
        v.$\pi$ = NIL
    s.d = 0

RELAX(u, v, w)
    if v.d > u.d + w(u, v)
        v.d = u.d + w(u, v)
        v.$\pi$ = u
        return TRUE
    return FALSE

SET-UNION(s, v)
    return s + v

DIJKSTRA(G, w, s)
    INITIALIZE-SINGLE-SOURCE(G, s);
    let S be a new set
    let Q[len(G.V)] be a new priorityqueue
    for each vertex v in G.V
        INSERT(Q, v)
    while Q
        u = EXTRACT-MIN(Q)
        S = S | {u}
        for each vertex v in G.Adj(u)
            did-decrease = RELAX(u, v, w)
            if did-decrease
                DECREASE-KEY(Q, v, v.d)


DIJKSTRA-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 10
    adj-mat[1][4] = 5
    adj-mat[2][3] = 1
    adj-mat[2][4] = 2
    adj-mat[3][5] = 4
    adj-mat[4][2] = 3
    adj-mat[4][3] = 9
    adj-mat[4][5] = 2
    adj-mat[5][3] = 6

    w(u, v)
        return adj-mat[u.key][v.key]

    let G[adj-mat] be a new graph
    DIJKSTRA(G, w, G.V[1])
    print "done"

    for each u in G.V
        print u

DIJKSTRA-EXAMPLE()

// Queue operations
ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

BFS(G, s)
    // for each vertex u in G.V - {s}
    for each vertex u in G.V
        if u == s
            continue
        u.color = WHITE
        u.d = $\infty$
        u.$\pi$ = NIL
    s.color = GRAY
    s.d = 0
    s.$\pi$ = NIL
    let Q[len(G.V) + 1] be a new queue
    ENQUEUE(Q, s)
    while len(Q) > 0
        u = DEQUEUE(Q)
        for each vertex v in G.Adj(u)
            if v.color == WHITE
                v.color = GRAY
                v.d = u.d + 1
                v.$\pi$ = u
                ENQUEUE(Q, v)
        u.color = BLACK

BFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    BFS(G, G.V[1])
    for each u in G.V
        print u

DFS(G)
    for each vertex u in G.V
        u.color = WHITE
        u.$\pi$ = NIL
    time = 0
    for each vertex u in G.V
        if u.color == WHITE
            DFS-VISIT(G, u, time)

DFS-VISIT(G, u, time)
    time = time + 1
    u.d = time
    u.color = GRAY
    for each vertex v in G.Adj(u)
        if v.color == WHITE
            v.$\pi$ = u
            DFS-VISIT(G, v, time)
    u.color = BLACK
    time = time + 1
    u.f = time

DFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    DFS(G)
    for each u in G.V
        print str(u) + " f=" + str(u.f)

BUBBLESORT(A, n)
    for i = 1 to n - 1
        for j = n downto i + 1
            if A[j] < A[j - 1]
                exchange A[j] with A[j - 1]

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

A = [5, 4, 3, 2, 1]
print A
INSERTION-SORT(A, 5)
print A

MERGE(A, p, q, r)
    // this is a comment
    n$_L$ = q - p + 1
    n$_R$ = r - q
    let L[0:n$_L$ - 1] and R[0:n$_R$ - 1] be new arrays
    for i = 0 to n$_L$ - 1
        L[i] = A[p + i]
    for j = 0 to n$_R$ - 1
        R[j] = A[q + j + 1]
    i = 0
    j = 0
    k = p
    while i < n$_L$ and j < n$_R$
        if L[i] <= R[j]
            A[k] = L[i]
            i = i + 1
        else A[k] = R[j]
            j = j + 1
        k = k + 1
    while i < n$_L$
        A[k] = L[i]
        i = i + 1
        k = k + 1
    while j < n$_R$
        A[k] = R[j]
        j = j + 1
        k = k + 1

let A[1:10] be a new array
for i = 1 to 5
    A[i] = i + 10
    A[i + 5] = i + 10

print A
MERGE(A, 1, 5, 10)
print A

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

let A$_l$[1:5] be a new array
for i = 1 to 5
    A$_l$[i] = 6 - i
print A$_l$
INSERTION-SORT(A$_l$, 5)
print A$_l$

MATRIX-MULTIPLY(A, B, C, n)
    for i = 1 to n
        for j = 1 to n
            for k = 1 to n
                C[i][j] = C[i][j] + A[i][k] * B[k][j]

ONLINE-MAXIMUM(k, n)
    best-score = -infinity
    for i = 1 to k
        if score(i) > best-score
            best-score = score(i)
    for i = k + 1 to n
        if score(i) > best-score
            return i
    return n

PERMUTE-BY-CYCLE(A, n)
    let B[1:n] be a new array
    offset = RANDOM(1, n)
    for i = 1 to n
        dest = i + offset
        if dest > n
            dest = dest - n
        B[dest] = A[i]
    return B

let A[1:20] be a new array
for i = 1 to 20
    A[i] = 10 * i + RANDOM(0, 9)
print A
B = PERMUTE-BY-CYCLE(A, 20)
print B

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.1
PARENT(i)
    // could alternatively use i \\ 2
    return floor(i / 2)

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MIN-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] < A[i]
        smallest = l
    else
        smallest = i
    if r <= A.heap-size and A[r] < A[smallest]
        smallest = r
    if smallest != i
        exchange A[i] with A[smallest]
        MIN-HEAPIFY(A, smallest)

MIN-HEAP-MINIMUM(A)
    if A.heap-size < 1
        error "heap underflow"
    return A[1]

BUILD-MIN-HEAP(A, n)
    A.heap-size = n
    for i = PARENT(n) downto 1
        MIN-HEAPIFY(A, i)

EXTRACT-MIN(A)
    min = A[1]
    A[1] = A[A.heap-size]
    A.heap-size = A.heap-size - 1
    MIN-HEAPIFY(A, 1)
    return min

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MAX-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] > A[i]
        largest = l
    else largest = i
    if r <= A.heap-size and A[r] > A[largest]
        largest = r
    if largest != i
        exchange A[i] with A[largest]
        MAX-HEAPIFY(A, largest)

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.4
HEAPSORT(A, n)
    BUILD-MAX-HEAP(A, n)
    for i = n downto 2
        exchange A[1] with A[i]
        A.heap-size = A.heap-size - 1
        MAX-HEAPIFY(A, 1)

PARTITION(A, p, r)
    x = A[r]
    i = p - 1
    for j = p to r - 1
        if A[j] <= x
            i = i + 1
            exchange A[i] with A[j]
    exchange A[i + 1] with A[r]
    return i + 1

QUICKSORT(A, p, r)
    if p < r
        q = PARTITION(A, p, r)
        QUICKSORT(A, p, q - 1)
        QUICKSORT(A, q + 1, r)

COUNTING-SORT(A, n, k)
    let B[1:n] and C[0:k] be new arrays
    for i = 0 to k
        C[i] = 0
    for j = 1 to n
        C[A[j]] = C[A[j]] + 1
    // C[i] now contains the number of elements equal to i
    for i = 1 to k
        C[i] = C[i] + C[i - 1]
    // C[i] now contains the number of elements less than or equal to i
    // Copy A to B, starting from the enf od A
    for j = n downto 1
        B[C[A[j]]] = A[j]
        C[A[j]] = C[A[j]] - 1 // to handle duplicate values
    return B

LIST-INSERT(x, y)
    x.next = y.next
    x.prev = y
    if y.next != NIL
        y.next.prev = x
    y.next = x

LIST-INSERT'(x, y)
    x.next = y.next
    x.prev = y
    y.next.prev = x
    y.next = x

LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-SEARCH'(L, k)
    L.nil.key = k
    x = L.nil.next
    while x.key != k
        x = x.next
    if x == L.nil
        return NIL
    else return x

ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

STACK-EMPTY(S)
    if S.top == 0
        return TRUE
    else return FALSE

PUSH(S, x)
    if S.top == S.size
        error "overflow"
    else
        S.top = S.top + 1
        S[S.top] = x

POP(S)
    if STACK-EMPTY(S)
        error "underflow"
    else
        S.top = S.top - 1
        return S[S.top + 1]

// section 11.2

// linked list algorithms
LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-DELETE(L, x)
    if x.prev != NIL
        x.prev.next = x.next
    else L.head = x.next
    if x.next != NIL
        x.next.prev = x.prev

// dummy hash function impl.
h(x)
    return x

CHAINED-HASH-INSERT(T, k, x)
    let N[NIL,NIL,k,x] be a new listnode
    LIST-PREPEND(T[h(N.key)], N)

CHAINED-HASH-SEARCH(T, k)
    found = LIST-SEARCH(T[h(k)], k)
    if found != NIL
        return found.value
    else return NIL

CHAINED-HASH-DELETE(T, k)
    subject = LIST-SEARCH(T[h(k)], k)
    LIST-DELETE(T[h(k)], subject)

INORDER-TREE-WALK(x)
    if x != NIL
        INORDER-TREE-WALK(x.left)
        print x.key
        INORDER-TREE-WALK(x.right)

TREE-SEARCH(x, k)
    if x == NIL or k == x.key
        return x
    if k < x.key
        return TREE-SEARCH(x.left, k)
    else return TREE-SEARCH(x.right, k)

ITERATIVE-TREE-SEARCH(x, k)
    while x != NIL and k != x.key
        if k < x.key
            x = x.left
        else x = x.right
    return x

TREE-MINIMUM(x)
    while x.left != NIL
        x = x.left
    return x

TREE-MAXIMUM(x)
    while x.right != NIL
        x = x.right
    return x

TREE-INSERT(T, z)
    x = T.root
    y = NIL
    while x != NIL
        y = x
        if z.key < x.key
            x = x.left
        else x = x.right
    z.p = y
    if y == NIL
        T.root = z
    else if z.key < y.key
        y.left = z
    else y.right = z

TRANSPLANT(T, u, v)
    if u.p == NIL
        T.root = v
    else if u == u.p.left
        u.p.left = v
    else u.p.right = v
    if v != NIL
        v.p = u.p

TREE-DELETE(T, z)
    if z.left == NIL
        TRANSPLANT(T, z, z.right)
    else if z.right == NIL
        TRANSPLANT(T, z, z.left)
    else y = TREE-MINIMUM(z.right)
        if y != z.right
            TRANSPLANT(T, y, y.right)
            y.right = z.right
            y.right.p = y
        TRANSPLANT(T, z, y);
        y.left = z.left
        y.left.p = y

CUT-ROD(p, n)
    if n == 0
        return 0
    q = -$\infty$
    for i = 1 to n
        q = max(q, p[i] + CUT-ROD(p, n - i))
    return q

MEMOIZED-CUT-ROD(p, n)
    let r[0:n] be a new array
    for i = 0 to n
        r[i] = -$\infty$
    return MEMOIZED-CUT-ROD-AUX(p, n, r)

MEMOIZED-CUT-ROD-AUX(p, n, r)
    if r[n] >= 0
        return r[n]
    if n == 0
        q = 0
    else q = -$\infty$
        for i = 1 to n
            q = max(q, p[i] + MEMOIZED-CUT-ROD(p, n - i, r))
    r[n] = q
    return q

BOTTOM-UP-CUT-ROD(p, n)
    let r[0:n] be a new array
    r[0] = 0
    for j = 1 to n
        q = -$\infty$
        for i = 1 to j
            q = max(q, p[i] + r[j - i])
        r[j] = q
    return r[n]

let prices[1:10] be a new array
prices[1] = 1
prices[2] = 5
prices[3] = 8
prices[4] = 9
prices[5] = 12
prices[6] = 17
prices[7] = 17
prices[8] = 20
prices[9] = 24
prices[10] = 30
n = 4
max-price = CUT-ROD(prices, n)
print max-price

// Priority Queues
LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

PARENT(i)
    return i / 2

INSERT(Q, u)
    Q.heap-size = Q.heap-size + 1
    Q[Q.heap-size] = u
    DECREASE-KEY(Q, u, u.d)

MIN-HEAPIFY(Q, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= Q.heap-size and Q[l].d < Q[i].d
        smallest = l
    else
        smallest = i
    if r <= Q.heap-size and Q[r].d < Q[smallest].d
        smallest = r
    if smallest != i
        exchange Q[i] with Q[smallest]
        MIN-HEAPIFY(Q, smallest)

EXTRACT-MIN(Q)
    min = Q[1]
    Q[1] = Q[Q.heap-size]
    Q.heap-size = Q.heap-size - 1
    MIN-HEAPIFY(Q, 1)
    return min

DECREASE-KEY(Q, v, k)
    for i = 1 to Q.heap-size
        // key will have already been adjusted by RELAX
        if Q[i].key == v.key
            Q[i].d = k
            exchange Q[i] with Q[1]
            MIN-HEAPIFY(Q, 1)

INITIALIZE-SINGLE-SOURCE(G, s)
    for each vertex v in G.V
        v.d = $\infty$
        v.$\pi$ = NIL
    s.d = 0

RELAX(u, v, w)
    if v.d > u.d + w(u, v)
        v.d = u.d + w(u, v)
        v.$\pi$ = u
        return TRUE
    return FALSE

SET-UNION(s, v)
    return s + v

DIJKSTRA(G, w, s)
    INITIALIZE-SINGLE-SOURCE(G, s);
    let S be a new set
    let Q[len(G.V)] be a new priorityqueue
    for each vertex v in G.V
        INSERT(Q, v)
    while Q
        u = EXTRACT-MIN(Q)
        S = S | {u}
        for each vertex v in G.Adj(u)
            did-decrease = RELAX(u, v, w)
            if did-decrease
                DECREASE-KEY(Q, v, v.d)


DIJKSTRA-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 10
    adj-mat[1][4] = 5
    adj-mat[2][3] = 1
    adj-mat[2][4] = 2
    adj-mat[3][5] = 4
    adj-mat[4][2] = 3
    adj-mat[4][3] = 9
    adj-mat[4][5] = 2
    adj-mat[5][3] = 6

    w(u, v)
        return adj-mat[u.key][v.key]

    let G[adj-mat] be a new graph
    DIJKSTRA(G, w, G.V[1])
    print "done"

    for each u in G.V
        print u

DIJKSTRA-EXAMPLE()

// Queue operations
ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

BFS(G, s)
    // for each vertex u in G.V - {s}
    for each vertex u in G.V
        if u == s
            continue
        u.color = WHITE
        u.d = $\infty$
        u.$\pi$ = NIL
    s.color = GRAY
    s.d = 0
    s.$\pi$ = NIL
    let Q[len(G.V) + 1] be a new queue
    ENQUEUE(Q, s)
    while len(Q) > 0
        u = DEQUEUE(Q)
        for each vertex v in G.Adj(u)
            if v.color == WHITE
                v.color = GRAY
                v.d = u.d + 1
                v.$\pi$ = u
                ENQUEUE(Q, v)
        u.color = BLACK

BFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    BFS(G, G.V[1])
    for each u in G.V
        print u

DFS(G)
    for each vertex u in G.V
        u.color = WHITE
        u.$\pi$ = NIL
    time = 0
    for each vertex u in G.V
        if u.color == WHITE
            DFS-VISIT(G, u, time)

DFS-VISIT(G, u, time)
    time = time + 1
    u.d = time
    u.color = GRAY
    for each vertex v in G.Adj(u)
        if v.color == WHITE
            v.$\pi$ = u
            DFS-VISIT(G, v, time)
    u.color = BLACK
    time = time + 1
    u.f = time

DFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    DFS(G)
    for each u in G.V
        print str(u) + " f=" + str(u.f)

BUBBLESORT(A, n)
    for i = 1 to n - 1
        for j = n downto i + 1
            if A[j] < A[j - 1]
                exchange A[j] with A[j - 1]

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

A = [5, 4, 3, 2, 1]
print A
INSERTION-SORT(A, 5)
print A

MERGE(A, p, q, r)
    // this is a comment
    n$_L$ = q - p + 1
    n$_R$ = r - q
    let L[0:n$_L$ - 1] and R[0:n$_R$ - 1] be new arrays
    for i = 0 to n$_L$ - 1
        L[i] = A[p + i]
    for j = 0 to n$_R$ - 1
        R[j] = A[q + j + 1]
    i = 0
    j = 0
    k = p
    while i < n$_L$ and j < n$_R$
        if L[i] <= R[j]
            A[k] = L[i]
            i = i + 1
        else A[k] = R[j]
            j = j + 1
        k = k + 1
    while i < n$_L$
        A[k] = L[i]
        i = i + 1
        k = k + 1
    while j < n$_R$
        A[k] = R[j]
        j = j + 1
        k = k + 1

let A[1:10] be a new array
for i = 1 to 5
    A[i] = i + 10
    A[i + 5] = i + 10

print A
MERGE(A, 1, 5, 10)
print A

INSERTION-SORT(A, n)
    for i = 2 to n
        key = A[i]
        // Insert A[i] into the sorted subarray A[1:i-1]
        j = i - 1
        while j > 0 and A[j] > key
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key

let A$_l$[1:5] be a new array
for i = 1 to 5
    A$_l$[i] = 6 - i
print A$_l$
INSERTION-SORT(A$_l$, 5)
print A$_l$

MATRIX-MULTIPLY(A, B, C, n)
    for i = 1 to n
        for j = 1 to n
            for k = 1 to n
                C[i][j] = C[i][j] + A[i][k] * B[k][j]

ONLINE-MAXIMUM(k, n)
    best-score = -infinity
    for i = 1 to k
        if score(i) > best-score
            best-score = score(i)
    for i = k + 1 to n
        if score(i) > best-score
            return i
    return n

PERMUTE-BY-CYCLE(A, n)
    let B[1:n] be a new array
    offset = RANDOM(1, n)
    for i = 1 to n
        dest = i + offset
        if dest > n
            dest = dest - n
        B[dest] = A[i]
    return B

let A[1:20] be a new array
for i = 1 to 20
    A[i] = 10 * i + RANDOM(0, 9)
print A
B = PERMUTE-BY-CYCLE(A, 20)
print B

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.1
PARENT(i)
    // could alternatively use i \\ 2
    return floor(i / 2)

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MIN-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] < A[i]
        smallest = l
    else
        smallest = i
    if r <= A.heap-size and A[r] < A[smallest]
        smallest = r
    if smallest != i
        exchange A[i] with A[smallest]
        MIN-HEAPIFY(A, smallest)

MIN-HEAP-MINIMUM(A)
    if A.heap-size < 1
        error "heap underflow"
    return A[1]

BUILD-MIN-HEAP(A, n)
    A.heap-size = n
    for i = PARENT(n) downto 1
        MIN-HEAPIFY(A, i)

EXTRACT-MIN(A)
    min = A[1]
    A[1] = A[A.heap-size]
    A.heap-size = A.heap-size - 1
    MIN-HEAPIFY(A, 1)
    return min

LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

MAX-HEAPIFY(A, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= A.heap-size and A[l] > A[i]
        largest = l
    else largest = i
    if r <= A.heap-size and A[r] > A[largest]
        largest = r
    if largest != i
        exchange A[i] with A[largest]
        MAX-HEAPIFY(A, largest)

BUILD-MAX-HEAP(A, n)
    A.heap-size = n
    for i = floor(n / 2) downto 1
        MAX-HEAPIFY(A, i)

// section 6.4
HEAPSORT(A, n)
    BUILD-MAX-HEAP(A, n)
    for i = n downto 2
        exchange A[1] with A[i]
        A.heap-size = A.heap-size - 1
        MAX-HEAPIFY(A, 1)

PARTITION(A, p, r)
    x = A[r]
    i = p - 1
    for j = p to r - 1
        if A[j] <= x
            i = i + 1
            exchange A[i] with A[j]
    exchange A[i + 1] with A[r]
    return i + 1

QUICKSORT(A, p, r)
    if p < r
        q = PARTITION(A, p, r)
        QUICKSORT(A, p, q - 1)
        QUICKSORT(A, q + 1, r)

COUNTING-SORT(A, n, k)
    let B[1:n] and C[0:k] be new arrays
    for i = 0 to k
        C[i] = 0
    for j = 1 to n
        C[A[j]] = C[A[j]] + 1
    // C[i] now contains the number of elements equal to i
    for i = 1 to k
        C[i] = C[i] + C[i - 1]
    // C[i] now contains the number of elements less than or equal to i
    // Copy A to B, starting from the enf od A
    for j = n downto 1
        B[C[A[j]]] = A[j]
        C[A[j]] = C[A[j]] - 1 // to handle duplicate values
    return B

LIST-INSERT(x, y)
    x.next = y.next
    x.prev = y
    if y.next != NIL
        y.next.prev = x
    y.next = x

LIST-INSERT'(x, y)
    x.next = y.next
    x.prev = y
    y.next.prev = x
    y.next = x

LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-SEARCH'(L, k)
    L.nil.key = k
    x = L.nil.next
    while x.key != k
        x = x.next
    if x == L.nil
        return NIL
    else return x

ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

STACK-EMPTY(S)
    if S.top == 0
        return TRUE
    else return FALSE

PUSH(S, x)
    if S.top == S.size
        error "overflow"
    else
        S.top = S.top + 1
        S[S.top] = x

POP(S)
    if STACK-EMPTY(S)
        error "underflow"
    else
        S.top = S.top - 1
        return S[S.top + 1]

// section 11.2

// linked list algorithms
LIST-PREPEND(L, x)
    x.next = L.head
    x.prev = NIL
    if L.head != NIL
        L.head.prev = x
    L.head = x

LIST-SEARCH(L, k)
    x = L.head
    while x != NIL and x.key != k
        x = x.next
    return x

LIST-DELETE(L, x)
    if x.prev != NIL
        x.prev.next = x.next
    else L.head = x.next
    if x.next != NIL
        x.next.prev = x.prev

// dummy hash function impl.
h(x)
    return x

CHAINED-HASH-INSERT(T, k, x)
    let N[NIL,NIL,k,x] be a new listnode
    LIST-PREPEND(T[h(N.key)], N)

CHAINED-HASH-SEARCH(T, k)
    found = LIST-SEARCH(T[h(k)], k)
    if found != NIL
        return found.value
    else return NIL

CHAINED-HASH-DELETE(T, k)
    subject = LIST-SEARCH(T[h(k)], k)
    LIST-DELETE(T[h(k)], subject)

INORDER-TREE-WALK(x)
    if x != NIL
        INORDER-TREE-WALK(x.left)
        print x.key
        INORDER-TREE-WALK(x.right)

TREE-SEARCH(x, k)
    if x == NIL or k == x.key
        return x
    if k < x.key
        return TREE-SEARCH(x.left, k)
    else return TREE-SEARCH(x.right, k)

ITERATIVE-TREE-SEARCH(x, k)
    while x != NIL and k != x.key
        if k < x.key
            x = x.left
        else x = x.right
    return x

TREE-MINIMUM(x)
    while x.left != NIL
        x = x.left
    return x

TREE-MAXIMUM(x)
    while x.right != NIL
        x = x.right
    return x

TREE-INSERT(T, z)
    x = T.root
    y = NIL
    while x != NIL
        y = x
        if z.key < x.key
            x = x.left
        else x = x.right
    z.p = y
    if y == NIL
        T.root = z
    else if z.key < y.key
        y.left = z
    else y.right = z

TRANSPLANT(T, u, v)
    if u.p == NIL
        T.root = v
    else if u == u.p.left
        u.p.left = v
    else u.p.right = v
    if v != NIL
        v.p = u.p

TREE-DELETE(T, z)
    if z.left == NIL
        TRANSPLANT(T, z, z.right)
    else if z.right == NIL
        TRANSPLANT(T, z, z.left)
    else y = TREE-MINIMUM(z.right)
        if y != z.right
            TRANSPLANT(T, y, y.right)
            y.right = z.right
            y.right.p = y
        TRANSPLANT(T, z, y);
        y.left = z.left
        y.left.p = y

CUT-ROD(p, n)
    if n == 0
        return 0
    q = -$\infty$
    for i = 1 to n
        q = max(q, p[i] + CUT-ROD(p, n - i))
    return q

MEMOIZED-CUT-ROD(p, n)
    let r[0:n] be a new array
    for i = 0 to n
        r[i] = -$\infty$
    return MEMOIZED-CUT-ROD-AUX(p, n, r)

MEMOIZED-CUT-ROD-AUX(p, n, r)
    if r[n] >= 0
        return r[n]
    if n == 0
        q = 0
    else q = -$\infty$
        for i = 1 to n
            q = max(q, p[i] + MEMOIZED-CUT-ROD(p, n - i, r))
    r[n] = q
    return q

BOTTOM-UP-CUT-ROD(p, n)
    let r[0:n] be a new array
    r[0] = 0
    for j = 1 to n
        q = -$\infty$
        for i = 1 to j
            q = max(q, p[i] + r[j - i])
        r[j] = q
    return r[n]

let prices[1:10] be a new array
prices[1] = 1
prices[2] = 5
prices[3] = 8
prices[4] = 9
prices[5] = 12
prices[6] = 17
prices[7] = 17
prices[8] = 20
prices[9] = 24
prices[10] = 30
n = 4
max-price = CUT-ROD(prices, n)
print max-price

// Priority Queues
LEFT(i)
    return 2 * i

RIGHT(i)
    return 2 * i + 1

PARENT(i)
    return i / 2

INSERT(Q, u)
    Q.heap-size = Q.heap-size + 1
    Q[Q.heap-size] = u
    DECREASE-KEY(Q, u, u.d)

MIN-HEAPIFY(Q, i)
    l = LEFT(i)
    r = RIGHT(i)
    if l <= Q.heap-size and Q[l].d < Q[i].d
        smallest = l
    else
        smallest = i
    if r <= Q.heap-size and Q[r].d < Q[smallest].d
        smallest = r
    if smallest != i
        exchange Q[i] with Q[smallest]
        MIN-HEAPIFY(Q, smallest)

EXTRACT-MIN(Q)
    min = Q[1]
    Q[1] = Q[Q.heap-size]
    Q.heap-size = Q.heap-size - 1
    MIN-HEAPIFY(Q, 1)
    return min

DECREASE-KEY(Q, v, k)
    for i = 1 to Q.heap-size
        // key will have already been adjusted by RELAX
        if Q[i].key == v.key
            Q[i].d = k
            exchange Q[i] with Q[1]
            MIN-HEAPIFY(Q, 1)

INITIALIZE-SINGLE-SOURCE(G, s)
    for each vertex v in G.V
        v.d = $\infty$
        v.$\pi$ = NIL
    s.d = 0

RELAX(u, v, w)
    if v.d > u.d + w(u, v)
        v.d = u.d + w(u, v)
        v.$\pi$ = u
        return TRUE
    return FALSE

SET-UNION(s, v)
    return s + v

DIJKSTRA(G, w, s)
    INITIALIZE-SINGLE-SOURCE(G, s);
    let S be a new set
    let Q[len(G.V)] be a new priorityqueue
    for each vertex v in G.V
        INSERT(Q, v)
    while Q
        u = EXTRACT-MIN(Q)
        S = S | {u}
        for each vertex v in G.Adj(u)
            did-decrease = RELAX(u, v, w)
            if did-decrease
                DECREASE-KEY(Q, v, v.d)


DIJKSTRA-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 10
    adj-mat[1][4] = 5
    adj-mat[2][3] = 1
    adj-mat[2][4] = 2
    adj-mat[3][5] = 4
    adj-mat[4][2] = 3
    adj-mat[4][3] = 9
    adj-mat[4][5] = 2
    adj-mat[5][3] = 6

    w(u, v)
        return adj-mat[u.key][v.key]

    let G[adj-mat] be a new graph
    DIJKSTRA(G, w, G.V[1])
    print "done"

    for each u in G.V
        print u

DIJKSTRA-EXAMPLE()

// Queue operations
ENQUEUE(Q, x)
    Q[Q.tail] = x
    if Q.tail == Q.size
        Q.tail = 1
    else Q.tail = Q.tail + 1
    if Q.tail == Q.head
        error "overflow"

DEQUEUE(Q)
    x = Q[Q.head]
    if Q.head == Q.size
        Q.head = 1
    else Q.head = Q.head + 1
    return x

BFS(G, s)
    // for each vertex u in G.V - {s}
    for each vertex u in G.V
        if u == s
            continue
        u.color = WHITE
        u.d = $\infty$
        u.$\pi$ = NIL
    s.color = GRAY
    s.d = 0
    s.$\pi$ = NIL
    let Q[len(G.V) + 1] be a new queue
    ENQUEUE(Q, s)
    while len(Q) > 0
        u = DEQUEUE(Q)
        for each vertex v in G.Adj(u)
            if v.color == WHITE
                v.color = GRAY
                v.d = u.d + 1
                v.$\pi$ = u
                ENQUEUE(Q, v)
        u.color = BLACK

BFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    BFS(G, G.V[1])
    for each u in G.V
        print u

DFS(G)
    for each vertex u in G.V
        u.color = WHITE
        u.$\pi$ = NIL
    time = 0
    for each vertex u in G.V
        if u.color == WHITE
            DFS-VISIT(G, u, time)

DFS-VISIT(G, u, time)
    time = time + 1
    u.d = time
    u.color = GRAY
    for each vertex v in G.Adj(u)
        if v.color == WHITE
            v.$\pi$ = u
            DFS-VISIT(G, v, time)
    u.color = BLACK
    time = time + 1
    u.f = time

DFS-EXAMPLE()
    let adj-mat[1:5] be a new array
    for i = 1 to 5
        let row[1:5] be a new array
        adj-mat[i] = row
        for j = 1 to 5
            adj-mat[i][j] = 0

    adj-mat[1][2] = 1
    adj-mat[1][3] = 1
    adj-mat[2][4] = 1
    adj-mat[3][5] = 1
    adj-mat[4][5] = 1

    let G[adj-mat] be a new graph
    DFS(G)
    for each u in G.V
        print str(u) + " f=" + str(u.f)
